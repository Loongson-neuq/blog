---
title: "[OS Week6] 内存管理 2 & Rust 所有权"
date: 2024-11-24
description: 内存管理 2 & Rust 所有权
tags:
  - Rust
categories:
  - OS
---

# 关于课程计划

由于临近期末（一月初考试），同时我们（助教）最近在编写操作系统（可以看到我又换回了 Arch Linux 进行工作）上占用大量时间，所以我们决定尽快结束课程。预计下一周是最后一周课程。计划下周讲解协程及 Async/Await 等内容。原计划第 13 周讲解的 Dynamic Dispatch 被取消。因为大家对 OOP 的理解不够深入，而且 Rust 的 OOP 与传统 OOP 有很大不同，所以我们决定取消这一部分内容。

同时，Dynamic Dispatch 也不是原计划的内容，原计划的内容仍然会在下周讲解完毕。

## 关于作业

从本周开始，不再布置作业。仅有最后一份期末作业，涉及到本学期所有的内容以及编写操作系统所需要的所有基本知识。Rustlings 和期末作业的参考答案我已经完成，下周一并发布。期末作业大家自行完成即可，不需要提交。有疑问还是请及时联系助教。

https://github.com/Loongson-neuq/2024-neuq-os-2024-neuq-final-assignment-1

目前这份作业中涉及的内容只有以下部分还没有讲解：
- 系统调用
- 锁/原子操作
- 协程
- Async/Await

前三个部分会在这节课讲解完毕，协程和 Async/Await 会在下周讲解。

### 后面的路怎么走？

有很多同学很迷茫，总是问我学完了能会什么，或者学完了就能编写操作系统了吗？

我可以负责任地告诉大家，大部分同学仍然离操作系统编写很远。但是知识是日积月累而不是一蹴而就的。你要清楚一个事实，操作系统是一个非常庞大的系统，涉及到的知识非常多，而且很多知识都是非常深入的。你花的几个月的间断的学习，凭什么能超过别人数年甚至数十年的积累？更别说别人经验比你丰富，基础比你扎实，会的知识面比你广泛。

再问自己一些问题：
- 你有丰富的软件工程经验吗？ 你能写出高质量的代码吗？高质量意味者代码可读性好，可维护性好，性能好，安全性好。你能写出这样的代码吗？
- 你有大型项目的经验吗？你最多的一个项目写过几万行代码？你有没有一个人参与过一个项目的设计，开发，测试，部署，维护的全过程？
- 你有多少编程语言的经验？你有多少编程范式的经验？你有多少编程工具的经验？

这些只是编程的基础，编写操作系统，要求你的编程基础非常扎实，更需要的是对操作系统原理的深入理解，对硬件的深入理解，对软硬件协同的深入理解。操作系统是软件与硬件高度耦合的产物。你既要对软件有深入理解，又要对硬件有深入理解。你要知道你的代码是如何在硬件上运行的，你的代码是如何与硬件交互的。

对软件的深入理解意味着你要对编程语言有深入理解，你看着高级语言的代码，就能知道它是如何在底层运行的。会执行哪些指令，会访问哪些内存，会调用哪些系统调用。

对硬件的深入理解意味着你要对计算机组成原理有深入理解，你要知道计算机是如何工作的，CPU 是如何工作的，内存是如何工作的，外设是如何工作的。对软硬件协同的深入理解意味着你要知道操作系统是如何管理硬件的，是如何与硬件交互的，是如何保证软硬件的正确协同工作的。

那是不是就搞不出来了呢？当然不是。你需要慢慢积累，慢慢学习。并且我同样可以负责任地告诉你，学习操作系统是提升底层编程能力的最快途径。只是需要一定知识基础的。

**关于 rcore 实验，如果你已经明显感觉到自己难以理解某些操作系统的概念，我的建议是立即停止。以提升软件工程能力为主，等你有了一定的软件工程能力，再回过头来学习操作系统，会事半功倍。**否则目前的学习只会让你感到困惑，所谓的学习也只是抄代码，能学到的东西非常有限。

最早的计划是要包含对软件工程的训练的，要求大家独立完成一个大型项目，同时包含设计模式的训练和课程，考虑到大家还是比较急于学习操作系统，所以这部分内容被取消了，只保留了编写操作系统需要的主线知识。

## 上次作业

上次的作业的完成的情况我就不多说了，大家自己清楚，也没有人来问问题。我只能认为大家可能还有些困难，那这节课我来带着大家完成，顺便讲解一下如何手动使用系统调用。

### 简答题

关于简答题，大部分都是上次课件里的内容，直接参考课件即可。这里我只讲解一下一些补充内容。

#### 手动使用 brk 系统调用

题目："尝试使用 brk 或 sbrk 分配 1024 字节，并尝试访问第 1024 ~ 4095 字节的内存，说明为什么可以访问这些内存？"

这里以 brk 系统调用为例，讲解一下系统调用是什么，如何使用系统调用。

##### 系统调用

系统调用是操作系统提供给用户程序的接口，用户程序通过系统调用可以请求操作系统提供服务。系统调用是用户态程序与内核态程序之间的桥梁。用户态程序通过系统调用请求内核态程序执行某些操作，比如读写文件，分配内存等。

看着比较抽象？实际上，就跟你调用外部库的一个函数一样。只不过这个函数是操作系统提供的，你需要通过一些*特殊*的方式调用。

下面我们从另一个角度，来看看系统调用到底是怎么*特殊*的。

系统调用是操作系统的一种**异常**。而**异常**和**中断**在操作系统中都属于**Trap**。Trap 是一种异步事件，它会打断 CPU 的正常执行流程，转而执行操作系统内核中的一段代码。这段代码就是系统调用的实现。

本质上来说，当**Trap**发生的一瞬间，会发生一下改变：
- CPU特权级被提升，从用户态提升到内核态 x86 中是从 ring3 提升到 ring0。RISC-V 中是从 U 模式提升到 S 模式。
- PC 指针被修改，指向内核态的代码。PC 指针是 CPU 核心当前/或下一条执行指令的地址，操作它就是操作 CPU 的执行流程。

这两者是同时且瞬间发生的，从发生异常的指令到内核态代码执行，这个过程是没有空隙的，是瞬间完成的。

当**Trap**发生后，也就是 PC 来到了操作系统的代码，操作系统会首先保存用户态的寄存器状态，然后根据 Trap 的类型，执行相应的操作。

如果是系统调用，操作系统会根据用户传递的参数，执行**相应的操作**，然后将结果返回给用户程序。这个过程是一个**系统调用**的过程。例如 brk 就是给用户程序分配内存的系统调用，exit 是退出程序的系统调用。

系统调用由特殊汇编指令触发，在 x86 中是 syscall 指令，在 RISC-V 中是 ecall 指令。在进入操作系统 Trap 后，操作系统可以读取 CPU 特权寄存器，判断 Trap 到底是 Exception 还是 Interrupt。Exception 是 Syscall，还是其他异常。根据这些信息，操作系统可以执行相应的操作。

如果是其他不可恢复的异常，比如除零异常，操作系统会直接终止用户程序的执行（由于信号机制的出现，操作系统现在通常不会直接杀死进程），然后将控制权交给其他程序。操作系统也会利用异常来实现一些功能，比如页错误异常，就是操作系统用来实现虚拟内存和COW的一种方式。

而**中断**是一种异步事件，分为硬中断和软中断。外部中断是由硬件设备发出的，比如键盘中断（仅针对PS接口，USB接口是轮询机制），网卡中断等，目的是让 CPU 处理硬件设备的事件。时钟中断是由CPU时钟发出的，目的是让 操作系统从用户程序中夺回控制权，进行调度。如果没有时钟中断，CPU 就会一直执行用户程序，操作系统就无法进行调度。假如我在这里写一个死循环，那么其他进程就无法被执行，因为同一时刻一个CPU的PC只能指向一个地址。t同时操作系统的代码也永远无法执行，也就意味着操作系统无法杀死这个进程。

因此，异常是操作系统与用户程序交互的方式，中断是操作系统夺回 CPU 控制权的方式。

下面来看看我们如何触发一个系统调用。

在 x86 中，我们可以使用 syscall 指令来触发系统调用。使用系统调用，我们需要做以下几件事：
- 在指定寄存器中存放系统调用号，这个号码是操作系统用来查找系统调用的实现。因为所有系统调用都是通过syscall指令触发的，所以操作系统需要根据这个号码来查找对应的系统调用实现。
- 在指定寄存器中存放系统调用的参数，这些参数是用户程序传递给操作系统的，操作系统根据这些参数来执行相应的操作。

参数必须是寄存器宽度的，因为我们只能通过寄存器传递参数。在 x86 中，系统调用的参数是通过 rax, rdi, rsi, rdx, r10, r8, r9 这几个寄存器传递的。rax 寄存器存放系统调用号，rdi, rsi, rdx, r10, r8, r9 分别存放系统调用的参数。在 RISC-V 中，系统调用的参数是通过 a0, a1, a2, a3, a4, a5 这几个寄存器传递的。
a7 寄存器存放系统调用号。上面的期末作业中给出了一些系统调用的号码，这些号码是操作系统用来查找系统调用实现的。

这里给出一个 x86_64 的 syscall 表，包含系统调用的寄存器使用约定: https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/

可以看到，系统调用的返回值是存放在 rax 寄存器中的。系统调用 id 也被放在 rax 寄存器中。然后我们还需要在 rdi 中放置第一个参数。

```Rust
#![no_std]
#![no_main]

use core::arch::asm;
use core::panic::PanicInfo;

#[allow(unused)]
#[allow(unused_mut)]
#[allow(unreachable_code)]
#[no_mangle]
pub extern "C" fn main() {
    let brk_start: usize;

    unsafe {
        // brk 是指向用户堆的指针。我们使用brk是扩大堆的大小，也就是分配内存。
        // 但是我们需要知道堆的起始位置，所以我们需要先获取当前的brk值。
        asm!(
            "mov rax, 12",  // sys_brk system call number on x86_64
            "mov rdi, 0",   // brk(0) to get the current brk value
            "syscall",
            out("rax") brk_start,
            options(nostack)
        );

        let mut new_brk: usize = brk_start + 1024; // 分配 1024 字节内存

        let brk_ret: isize; // 系统调用返回值

        // 调用 brk 系统调用进行内存分配
        asm!(
            "mov rax, 12",  // sys_brk system call number on x86_64
            "syscall",
            in("rdi") new_brk,
            out("rax") brk_ret,
            options(nostack)
        );

        if brk_ret == -1 {
            new_brk = brk_start; // 分配失败，恢复原来的 brk
            panic!("brk failed");
        }

        let mut ptr = brk_start as *mut u8;
        ptr.write_volatile(42); // 访问 brk 的第一个字节

        print("brk success\n");

        for i in 0..4099 {
            unsafe {
                ptr.add(i).write_volatile(42); // 访问超出分配的内存
                // 你应该一定会看到4096行的write success。一行不多，一行不少。
                print("write success\n");
            }
        }
    }
}

#[no_mangle]
pub extern "C" fn __libc_start_main() -> ! {
    main();

    print("main returned\n");

    exit(0);
}

pub fn print(s: &str) {
    let ptr = s.as_ptr();
    let count = s.len();
    unsafe {
        asm!("syscall",
            in("rax") 1, // sys_write system call number on x86_64
            in("rdi") 1, // file descriptor 1 is stdout
            in("rsi") ptr, // pointer to the buffer
            in("rdx") count, // buffer size
        )
    }
}

fn exit(code: i32) -> ! {
    unsafe {
        // 退出程序
        asm!("syscall",
            in("rax") 60, // sys_exit system call number on x86_64
            in("rdi") code, // exit code;
            options(noreturn, nostack)
        )
    }
}

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    print("panicked!\n");
    exit(1);
}
```

你可以在[这里](https://github.com/Loongson-neuq/blog/tree/main/content/post/week060/brk_demo)找到这个代码的完整版本。

使用

```bash
cargo +nightly run -Z build-std=core --target x86_64-unknown-linux-gnu
```

来编译运行

你可以看到，刚好在第 4096 行的时候，程序会被操作系统杀死。这是因为我们访问了超出分配的内存，操作系统检测到了这个错误，就会杀死程序。

但是我们明明只要了 1024 个字节，为什么我们可以访问 4096 字节呢？这是因为操作系统会按照页的大小来分配内存。在 x86_64 上，页的大小是 4096 字节。所以我们分配 1024 字节的时候，实际上操作系统会分配 4096 字节的内存。这个内存是连续的，所以我们可以访问 1024 ~ 4095 字节的内存。按页分配内存是为了提高内存的使用效率，因为内存是按页来管理的，所以我们只能按页来分配内存。分页机制同时也是虚拟内存和内存权限控制的基础。

上面你可以看到我使用汇编调用`exit`, `write`系统调用的实现，这是因为我们在 `no_std` 环境下，没有标准库，所以我们需要自己实现这些功能。这里我使用了汇编来调用系统调用。
