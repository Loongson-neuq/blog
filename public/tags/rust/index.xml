<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on NEUQ 龙芯实验室博客</title><link>https://loongson-neuq.pages.dev/tags/rust/</link><description>Recent content in Rust on NEUQ 龙芯实验室博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 27 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://loongson-neuq.pages.dev/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>[OS Week2] Get started with Rust</title><link>https://loongson-neuq.pages.dev/p/os-week2-get-started-with-rust/</link><pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate><guid>https://loongson-neuq.pages.dev/p/os-week2-get-started-with-rust/</guid><description>&lt;p>本次课程的部分内容摘抄自 &lt;a class="link" href="https://learn.microsoft.com/learn" target="_blank" rel="noopener"
>Microsoft Learn&lt;/a> 上的 &lt;a class="link" href="https://learn.microsoft.com/zh-cn/windows/dev-environment/rust/" target="_blank" rel="noopener"
>Get started with Rust&lt;/a> 课程。&lt;/p>
&lt;h2 id="overview">Overview
&lt;/h2>&lt;p>Rust 是一种系统编程语言，因此可用于编写系统（如操作系统）。 但它也可用于编写性能和可信度很重要的应用程序。 Rust 语言语法可以与 C++ 语法相媲美，提供了与新式 C++ 相当的性能；&lt;/p>
&lt;blockquote>
&lt;p>❕INFO&lt;/p>
&lt;p>  C++是什么垃圾也配&lt;/p>
&lt;/blockquote>
&lt;p>对于许多有经验的开发人员来说，Rust 在编译和运行时模型、类型系统和确定性终止化方面都是正确的。&lt;/p>
&lt;blockquote>
&lt;p>❕INFO&lt;/p>
&lt;p>  在系统编程中，控制流可能被扰乱，某些优化并不完全正确，需要开发者具有丰富的经验对生成的汇编代码进行审查。不能完全依赖编译器。&lt;/p>
&lt;/blockquote>
&lt;p>此外，Rust 的设计保证了内存安全，而不需要进行垃圾回收。&lt;/p>
&lt;p>那么，我们为什么要选择 Rust 作为 Windows 的最新语言投影呢？ 其中一个因素是，Stack Overflow 的年度开发人员调查显示，Rust 是目前为止年复一年最受欢迎的编程语言。 虽然你可能会发现此语言有陡峭的学习曲线，但一旦你越过了这个峰，就很难不爱上它了。&lt;/p>
&lt;h2 id="rust-development-toolsetecosystem">Rust development toolset/ecosystem
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>&lt;code>crate&lt;/code> 是 Rust &lt;strong>编译&lt;/strong>和&lt;strong>链接&lt;/strong>单元。 crate 可以源代码形式存在，然后能够被处理成以二进制可执行文件（简称二进制文件）或二进制库（简称库）形式存在的 crate 。通常一个 crate 就是一个 &lt;strong>project&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Rust 项目称为&lt;code>包&lt;/code>。 一个包可以包含一个或多个 crate，以及描述如何生成这些 crate 的 &lt;code>Cargo.toml&lt;/code> 文件。更准确的说法是 &lt;strong>solution&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>rustup&lt;/code> 是 Rust 工具链的安装程序和更新程序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Cargo&lt;/code> 是 Rust 包管理工具的名称。也用于构建、测试和发布 Rust 项目。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>rustc&lt;/code> 是 Rust 编译器。 大多数情况下，你不会直接调用 rustc，而是通过 Cargo 间接调用它。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>crates.io&lt;/code> (&lt;a class="link" href="https://crates.io/" target="_blank" rel="noopener"
>https://crates.io/&lt;/a>) 是 Rust 社区的 crate 注册表。crates.io 托管大量的 crate，可以通过 Cargo 下载，并自动解决依赖关系。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="progarmming-language-concepts">Progarmming language Concepts
&lt;/h2>&lt;h3 id="type-syetem">Type syetem
&lt;/h3>&lt;h4 id="strong-typing-weak-typing">Strong typing? Weak typing?
&lt;/h4>&lt;p>在编程语言的类型系统中，强类型（strong typing）和弱类型（weak typing）是两个核心概念，用于描述编程语言对数据类型的约束程度。&lt;/p>
&lt;h3 id="强类型strong-typing">强类型（Strong Typing）
&lt;/h3>&lt;p>强类型语言要求变量的数据类型在使用时要严格遵守，通常不允许不同类型之间的隐式转换。例如，Rust、.NET都属于强类型语言。以下是强类型的特征：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>严格的类型检查&lt;/strong>：强类型语言在&lt;strong>编译期&lt;/strong>或运行期都会进行严格的类型检查，如果类型不匹配，代码就会报错。例如，在Rust中将整数赋值给一个字符串类型的变量会直接报错，而不会自动转换类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>安全性&lt;/strong>：强类型语言通常可以防止许多潜在的错误，因为它们在操作不兼容类型时会立即报错，帮助程序员更早地发现错误。例如在Rust中，试图将整型变量作为浮点型来处理，编译器会立即提醒，这避免了许多运行时错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类型转换需要显式&lt;/strong>：在强类型语言中，类型转换一般需要显式声明，编译器不会进行隐式转换。例如在Rust中，&lt;code>let x: i32 = 10; let y: f64 = x as f64;&lt;/code>。&lt;code>as&lt;/code>关键字显式地将&lt;code>i32&lt;/code>类型转换成了&lt;code>f64&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>⚠️ NOTE&lt;/p>
&lt;p>  Rust 仅在安全的情况下允许隐式转换，例如&lt;code>let x: i32 = 10; let y: f64 = x;&lt;/code>是合法的，因为&lt;code>i32&lt;/code>可以隐式转换成&lt;code>f64&lt;/code>。并且 Rust 还有&lt;strong>自动解引用&lt;/strong>机制，实现了一定程度的隐式转换。&lt;/p>
&lt;/blockquote>
&lt;ol start="4">
&lt;li>&lt;strong>内存安全&lt;/strong>：强类型语言更容易实现内存安全，因为严格的类型系统有助于防止无效的内存访问。例如，Rust的所有权系统和借用检查在类型系统中嵌入了内存管理的概念，确保了线程安全和内存安全。&lt;/li>
&lt;/ol>
&lt;h3 id="弱类型weak-typing">弱类型（Weak Typing）
&lt;/h3>&lt;p>弱类型语言对类型的限制较少，通常允许不同类型之间的隐式转换，例如C和JavaScript都具有弱类型的特性。以下是弱类型的特征：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>更宽松的类型转换&lt;/strong>：弱类型语言在不同类型之间可以自由转换。例如在JavaScript中，&lt;code>&amp;quot;5&amp;quot; + 10&lt;/code> 会自动将数字&lt;code>10&lt;/code>转换成字符串，然后得到字符串&lt;code>&amp;quot;510&amp;quot;&lt;/code>。这种隐式转换提供了便利，但也可能导致难以发现的错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>更高的灵活性&lt;/strong>：弱类型允许开发者快速编写代码，减少了类型检查的约束，代码在运行时的适应性更高。例如，JavaScript中的函数可以接受任何类型的参数，不必进行严格的类型定义。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>容易出错&lt;/strong>：由于类型不严格，弱类型语言更容易引发错误，尤其是在无意中发生隐式类型转换时。比如在C语言中，整数和指针之间可以自由转换，这会导致很多内存和安全问题。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="rust-的强类型优势">Rust 的强类型优势
&lt;/h3>&lt;p>Rust 是一种强类型系统的语言，其设计注重内存安全和性能，通过严格的类型检查和所有权模型来保证代码的可靠性。Rust 的强类型特性让开发者在编译时可以捕捉到许多潜在的错误，减少了运行时的崩溃风险，同时通过显式转换机制避免了隐式转换带来的隐患。&lt;/p>
&lt;p>最后，类型是仅对于高级语言抽象层的概念，在底层的硬件层，一切都是二进制的。所有的类型实例不过是一段 memory block，在汇编中我们使用同样的指令来操作所有的类型。因此，在 C 这种仅对汇编进行薄封装的语言中，类型的概念并不是很重要。&lt;/p>
&lt;h3 id="systems-programming-language">Systems programming language
&lt;/h3>&lt;p>“系统编程语言”通常指的是适合底层开发、硬件交互和性能优化的语言，与更高层抽象的应用编程语言相比，它们有一些独特的特点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>直接硬件访问和内存控制&lt;/strong>(Most important to us)：
系统编程语言通常支持对硬件和内存进行低层次的访问，例如手动管理内存（Rust、C/C++的&lt;code>malloc/free&lt;/code>或&lt;code>new/delete&lt;/code>）。这让开发者能精确控制程序的内存分配和释放，提高性能和资源利用率。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>高效的执行性能&lt;/strong>：
系统编程语言（如Rust、C、C++）通常会编译成原生机器码（针对特定架构及操作系统的汇编指令），以确保代码在执行时的效率和速度。这在操作系统、嵌入式系统等需要实时响应和高效性能的场景中尤为重要。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>⚠️ NOTE&lt;/p>
&lt;p>  不完全正确，事实上，JIT 和 GC 的组合更能够在保证极端性能的完全释放和最大延迟。只是 JIT 依赖运行时，并且 GC 不能保证确定性时延。这些缺陷在系统编程中是不可接受的。因为运行时依赖操作系统。而 GC 导致的不确定性时延会导致系统的不可预测性。&lt;/p>
&lt;/blockquote>
&lt;ol start="3">
&lt;li>
&lt;p>&lt;strong>细粒度的并发控制&lt;/strong>：
系统编程语言支持低级并发控制（如Rust中的无锁数据结构、C++的线程库和原子操作）。Rust特别强调安全的并发，通过借用检查器和所有权系统来避免数据竞争，帮助在保持并发性能的同时防止线程安全问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>内存安全&lt;/strong>：
像Rust这样的现代系统编程语言注重内存安全，避免空指针和悬空指针等问题。Rust的所有权系统在编译期防止了数据竞争、悬挂引用和双重释放等内存问题，大幅降低了由于内存管理引发的漏洞风险。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>零成本抽象&lt;/strong>：
系统编程语言（特别是Rust和C++）支持高效的抽象机制，允许编写高性能、模块化的代码。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>系统编程语言的这些特点使它们适合于操作系统、驱动程序、嵌入式系统、数据库引擎和游戏引擎等对性能和硬件直接交互有严格要求的场景。相比之下，高层次的编程语言（如Python、JavaScript）更适合于快速开发和构建应用程序接口（API）、数据处理或前端交互，因为它们提供了更丰富的标准库、内置内存管理和更高的抽象能力，但牺牲了一部分性能和对系统的直接控制。&lt;/p>
&lt;h2 id="why-rust">Why Rust?
&lt;/h2>&lt;p>我们要编写的是操作系统内核，不是一般的用户程序！&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>内存安全性&lt;/strong>：Rust独特的所有权系统和借用检查机制在编译阶段保证了内存安全，避免了常见的内存错误，如空指针引用、悬空指针和数据竞争问题。这对于编写操作系统内核尤为重要，因为内核中的错误通常会导致系统崩溃。Rust的安全检查帮助新手在不依赖垃圾回收的情况下实现更高的内存安全性，从而在早期阶段减少调试和崩溃问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>现代化语法，开发者友好&lt;/strong>：Rust的语法较为现代化且接近高级语言，易于理解。相比传统的系统编程语言（如C/C++），Rust能让新手更快上手，写出结构化、可读性高的代码，从而减少理解操作系统开发的语言门槛，使其更专注于系统逻辑和底层实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>高效的错误信息和强类型系统&lt;/strong>：Rust的编译器提供详细的错误提示，帮助开发者快速定位和解决问题。Rust的强类型系统在编译时检查代码中的潜在错误，特别是在内核开发中，这种类型检查可以大大减少运行时的错误和潜在的安全漏洞。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>低层次控制和高性能&lt;/strong>：Rust与C一样可以访问底层硬件和控制内存布局，但同时还能提供更高的性能和资源控制能力。这使得新手能够更灵活地操作RISC-V平台的硬件资源，同时获得接近C的性能，这是编写高效操作系统内核的重要特性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>丰富的生态和社区支持&lt;/strong>：Rust社区对操作系统开发的支持日渐丰富，包括&lt;code>riscv&lt;/code> crate等对RISC-V架构的支持库、&lt;code>core&lt;/code>和&lt;code>alloc&lt;/code>等标准库，以及&lt;code>x86_64&lt;/code>和&lt;code>riscv&lt;/code>等架构支持工具。社区中有许多成熟的项目和开源代码可供参考，新手可以借鉴这些资源加速学习。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>无运行时、轻量编译选项&lt;/strong>：Rust允许在&lt;code>no_std&lt;/code>环境中开发，即不依赖标准库，从而更适合裸机（bare metal）开发。对于RISC-V平台操作系统内核，Rust可以使用&lt;code>#![no_std]&lt;/code>配置，这样就能完全剥离标准库，直接进行裸机编程，符合操作系统开发的需求。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="我最看重什么">我最看重什么？
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;strong>大量第三方库&lt;/strong>：Rust 社区的生态系统非常丰富，有大量的第三方库可供使用，可以大大提高开发效率。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>项目质量&lt;/strong>: 不规范换行？不规范缩进？不规范命名？clippy 全部给你报错！代码全部塞一个类一个函数里？测试过不了你就老实了！&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="rust-is-good-enough">Rust is good enough?
&lt;/h2>&lt;p>我不认为 Rust 够好，事实上它除了内存安全的一点保证之外远远能让我满意。上述的优点 Rust 也并没有做到最好。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>SUCK virtual dispatch: Rust 的多态性主要基于泛型，倾向于静态分派，在编译期生成专用代码来替代泛型参数，因此很少使用动态分派（dyn Trait），这提高了性能，但也限制了动态多态的灵活性。相比之下，.NET 提供了灵活的接口和虚函数机制，适合需要基于对象或接口进行频繁动态分派的场景。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SUCK async programming: 许多人认为 async/await 是 Rust 的一大优势，但实际上，Rust 的异步编程模型相对简陋。Rust 的异步编程主要基于&lt;code>Future&lt;/code>和&lt;code>async/await&lt;/code>语法，但缺乏像.NET Core中的&lt;code>Task&lt;/code>和&lt;code>async/await&lt;/code>那样完善的异步编程框架和库。Rust的异步编程需要依赖第三方库（如&lt;code>tokio&lt;/code>、&lt;code>async-std&lt;/code>）来实现，而且在使用过程中需要处理更多的错误和异常情况，不如.NET Core的异步编程模型简洁和易用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Macro? Garbage!: 我最讨厌的东西！宏分为两种，一种是声明式宏，一种是过程式宏。声明式宏类似 C 里面的宏，通常只用于简单的文本替换，只是添加了一些语法约束。过程宏是用于编译期代码生成的工具，但是 Rust 的过程宏相当简陋，仅支持 syntax analysis，.NET 的增量代码生成器则强大得多，不需要宏就能实现更强大的代码生成功能。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Rust 还有许多缺点，但是我认为不太重要，因此不再叙述。例如饱受诟病的编译速度慢，命名空间管理毫无逻辑等等。当然，Rust 太难不是 Rust 的问题。&lt;/p>
&lt;p>但是在我们的场景下，Rust 是最适合的语言。&lt;/p>
&lt;h2 id="setup-your-own-rust-development-environment">Setup your own Rust development environment
&lt;/h2>&lt;h3 id="prerequisites">Prerequisites
&lt;/h3>&lt;h4 id="windows">Windows
&lt;/h4>&lt;p>由于 Rust 依赖 C 编译套件用于编译的最终阶段，因此在 Windows 上安装 Rust 时，需要安装 C 编译套件。 Windows 上的 C 运行时主要是 MSVS，因此你需要安装 Microsoft Visual C++。你可以下载 &lt;a class="link" href="https://visualstudio.microsoft.com/visual-cpp-build-tools/" target="_blank" rel="noopener"
>Microsoft C++ Build Tools&lt;/a>，也可以（推荐）首选直接安装 &lt;a class="link" href="https://visualstudio.microsoft.com/downloads/" target="_blank" rel="noopener"
>Microsoft Visual Studio&lt;/a>。安装 Community 版本的 Visual Studio 即可。安装时仅勾选 &lt;strong>Desktop development with C++&lt;/strong> 选项即可。&lt;/p>
&lt;p>&lt;a class="link" href="https://rust-lang.github.io/rustup/installation/windows-msvc.html" target="_blank" rel="noopener"
>Detailed instructions&lt;/a>&lt;/p>
&lt;h4 id="linux">Linux
&lt;/h4>&lt;p>安装对应平台和与宿主主机相同的架构的 GCC 即可。&lt;/p>
&lt;h3 id="development-environment">Development environment
&lt;/h3>&lt;h4 id="rustrover">RustRover?
&lt;/h4>&lt;p>RustRover 是 JetBrains 开发的 Rust 语言的 IDE，它是一个基于 IntelliJ 平台的 IDE，提供了 Rust 语言的代码编辑、调试、自动补全、代码重构等功能。RustRover 也支持 Cargo 包管理工具，可以帮助你更方便地管理 Rust 项目。类似于 Idea, PyCharm, Clion 等。并且 RustRover 社区版是免费的。&lt;/p>
&lt;p>但是！&lt;/p>
&lt;p>不要用！由于我们的最终目的是系统编程，RustRover 是面向用户级应用的 IDE，它的调试器和代码提示等功能对于系统编程并不友好。&lt;/p>
&lt;p>因此我要求大家使用 Cargo 命令行　+　你自己喜欢的文本编辑器（VSCode, Vim, Emacs, Sublime Text, Notepad++）进行开发。&lt;/p>
&lt;h4 id="install-rust">Install Rust
&lt;/h4>&lt;p>不管你用的什么操作系统，打开 &lt;a class="link" href="https://rustup.rs" target="_blank" rel="noopener"
>&lt;code>https://rustup.rs&lt;/code>&lt;/a>。&lt;/p>
&lt;p>如果你是 Windows 用户，点击最上面的&lt;code>rustup-init.exe&lt;/code>下载并运行。
如果你是 Linux 用户，复制网址下面的命令到终端运行。&lt;/p>
&lt;p>然后根据提示，一路回车即可。&lt;/p>
&lt;blockquote>
&lt;p>某些发行版可能会将 &lt;code>rustup&lt;/code> 添加至软件源，当然上述方式也可以&lt;/p>
&lt;/blockquote>
&lt;h4 id="verify-installation">Verify installation
&lt;/h4>&lt;p>打开终端，输入&lt;code>cargo --version&lt;/code>，如果输出了版本号，说明安装成功。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="nb">PS &lt;/span>&lt;span class="n">C:&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">Users&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">Caiyi&lt;/span> &lt;span class="n">Hsu&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">cargo&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="n">-version&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">cargo&lt;/span> &lt;span class="mf">1.80&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="py">0&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mf">376290515&lt;/span> &lt;span class="mf">2024&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="mf">07&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="mf">16&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="rust-with-visual-studio-code">Rust with Visual Studio Code
&lt;/h3>&lt;p>确保你已经安装了 Visual Studio Code 和 Cargo。打开 Visual Studio Code，安装 &lt;code>rust-analyzer&lt;/code> 插件。&lt;/p>
&lt;p>More usages:&lt;/p>
&lt;p>&lt;a class="link" href="https://code.visualstudio.com/docs/languages/rust" target="_blank" rel="noopener"
>Rust with Visual Studio Code&lt;/a>&lt;/p>
&lt;h3 id="rust-basic-syntax">Rust basic syntax
&lt;/h3>&lt;!-- TODO 该干啥了？ -->
&lt;p>&lt;del>&lt;a class="link" href="https://doc.rust-lang.org/stable/book/" target="_blank" rel="noopener"
>The Rust Programming Language&lt;/a>&lt;/del>&lt;/p>
&lt;p>&lt;del>&lt;a class="link" href="https://kaisery.github.io/trpl-zh-cn/" target="_blank" rel="noopener"
>Unofficial Chinese Translation&lt;/a>&lt;/del>&lt;/p>
&lt;p>&lt;strong>强烈建议使用 Brown University 的实验性交互版本&lt;/strong>，尤其是对所有权和借用感到困惑的同学。&lt;/p>
&lt;p>&lt;strong>&lt;a class="link" href="https://rust-book.cs.brown.edu/" target="_blank" rel="noopener"
>rust-book.cs.brown.edu&lt;/a>&lt;/strong>&lt;/p>
&lt;p>如果感觉鸟语看着难受可以对照中文翻译看，但一定要以这个这个版本为主要材料。&lt;/p>
&lt;h3 id="下集预告">下集预告
&lt;/h3>&lt;p>有重量级内容，敬请期待！&lt;/p>
&lt;p>&lt;a class="link" href="https://loongson-neuq.pages.dev/p/advanced-rust/" target="_blank" rel="noopener"
>Understanding Rust via Memory management&lt;/a>&lt;/p>
&lt;p>做了 Rustlings 的同学可以提前看一下。&lt;/p></description></item><item><title>Advanced Rust</title><link>https://loongson-neuq.pages.dev/p/advanced-rust/</link><pubDate>Fri, 25 Oct 2024 00:00:00 +0000</pubDate><guid>https://loongson-neuq.pages.dev/p/advanced-rust/</guid><description>&lt;h2 id="prerequisite">Prerequisite
&lt;/h2>&lt;h3 id="memory-management">Memory Management
&lt;/h3>&lt;h4 id="stack">Stack
&lt;/h4>&lt;p>Remember:&lt;/p>
&lt;p>All variables you &lt;em>defined&lt;/em> in a function/method is allocated on the &lt;em>STACK&lt;/em>, even non-fixed size types and reference types.&lt;/p>
&lt;p>But the thing you can &lt;em>access&lt;/em> directly or actually stored on the stack must be fixed size types.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-Cpp" data-lang="Cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Object&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">obj&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;Hello, world&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">StructType&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">StructType&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>All variable you can use directly is allocated on the stack (frame).&lt;/p>
&lt;h5 id="this-is-not-what-i-heard-from-othersthe-internet">This is not what I heard from others/the Internet!
&lt;/h5>&lt;ul>
&lt;li>Reference types&lt;/li>
&lt;li>String&lt;/li>
&lt;li>Vector&lt;T>&lt;/li>
&lt;li>Dynamic allocation (eg. malloc)&lt;/li>
&lt;/ul>
&lt;p>People all told me that these types are allocated on the HEAP!&lt;/p>
&lt;p>I would say, that&amp;rsquo;s the root of your confusion. Why don&amp;rsquo;t we talk about the Heap first then?&lt;/p>
&lt;p>And I used two different term: &lt;code>define&lt;/code> and &lt;code>access&lt;/code>&lt;/p>
&lt;h4 id="heap">Heap
&lt;/h4>&lt;p>Heap is a large contigous memory managed by both the &lt;strong>Operating System&lt;/strong> and &lt;strong>the language runtime&lt;/strong>.&lt;/p>
&lt;p>Runtime may be the &lt;strong>Standard library&lt;/strong>, eg. the libC
or &lt;em>GC&lt;/em>, eg. Go, .NET &amp;hellip;&lt;/p>
&lt;p>We don&amp;rsquo;t have to care about what&amp;rsquo;s happening in the background, at least for now.&lt;/p>
&lt;p>We only care about two functions:&lt;/p>
&lt;ol>
&lt;li>One for alloacting memory&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">alloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">size_t&lt;/span> &lt;span class="n">size_of_bytes&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>which is &lt;code>malloc&lt;/code>, &lt;code>new&lt;/code>, &lt;code>new[]&lt;/code> &amp;hellip;&lt;/p>
&lt;ol start="2">
&lt;li>Another for returning allocated memory&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">free&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>which is &lt;code>free&lt;/code>, &lt;code>delete&lt;/code>, &lt;code>delete[]&lt;/code> &amp;hellip;&lt;/p>
&lt;p>One interesting thing you should have noticed is, when we returning a piece of memory, we only need to pass the pointer to the function, but not the size of the memory.&lt;/p>
&lt;p>Why? Because &lt;em>Someone&lt;/em> must have recorded the size of the memory when it was allocated.&lt;/p>
&lt;p>The guy is the &lt;strong>Memory Allocator&lt;/strong>, a part of the runtime.&lt;/p>
&lt;p>When you call alloc method, the allocator simply find a piece of memory that is large enough to hold the data you want to store, and then record the size of the memory.&lt;/p>
&lt;p>But where is the large piece of meory(the allocator uses) from?&lt;/p>
&lt;p>The answer is the &lt;strong>Operating System&lt;/strong>.&lt;/p>
&lt;p>The OS provides a system call to allocate a piece of memory, and the allocator will use this system call to get the memory.&lt;/p>
&lt;h5 id="unix-like-system">Unix-like system
&lt;/h5>&lt;p>The unix-like system provides a system call &lt;code>brk&lt;/code> or &lt;code>sbrk&lt;/code> to allocate memory.&lt;/p>
&lt;p>The system call is like the function below, but is NOT a real function.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">brk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nf">sbrk&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">intptr_t&lt;/span> &lt;span class="n">increment&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Additional info: &lt;a class="link" href="https://www.man7.org/linux/man-pages/man2/brk.2.html" target="_blank" rel="noopener"
>brk syscall&lt;/a>&lt;/p>
&lt;p>A note from the page:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">Avoid&lt;/span> &lt;span class="nx">using&lt;/span> &lt;span class="nf">brk&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="nx">and&lt;/span> &lt;span class="nf">sbrk&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="nx">the&lt;/span> &lt;span class="nf">malloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nx">memory&lt;/span> &lt;span class="nx">allocation&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">package&lt;/span> &lt;span class="nx">is&lt;/span> &lt;span class="nx">the&lt;/span> &lt;span class="nx">portable&lt;/span> &lt;span class="nx">and&lt;/span> &lt;span class="nx">comfortable&lt;/span> &lt;span class="nx">way&lt;/span> &lt;span class="nx">of&lt;/span> &lt;span class="nx">allocating&lt;/span> &lt;span class="nx">memory&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>When you call the brk, the OS will allocate memories Right After the end of the previous memory block. So when you constently call the brk, the memory block will grow larger and larger, but the memory block is always contiguous.&lt;/p>
&lt;p>The &lt;code>malloc&lt;/code> function will use the &lt;code>brk&lt;/code> system call to allocate memory, and uses the memory block for the allocation and recording the size of the memory.&lt;/p>
&lt;p>How do the OS gurantee the memory block is contiguous or the end of the memory block always have enough space for the next allocation?&lt;/p>
&lt;p>The answer is, the OS atually doesn&amp;rsquo;t gurantee that. Actually, memory pieces that a user program feels contiguous may &lt;em>NOT&lt;/em> be contiguous in the physical memory. The OS uses a technique called &lt;strong>Virtual Memory&lt;/strong> and &lt;strong>Page Table&lt;/strong> to make the memory block contiguous in the user program&amp;rsquo;s view.&lt;/p>
&lt;p>The OS simply maps the virtual memory to the physical memory. This technique is done with the help of hardwares like MMU, a part of the CPU.&lt;/p>
&lt;h5 id="windows">Windows
&lt;/h5>&lt;p>Windows does basically the same thing, but with a different system call, and the system call is wrapped by the &lt;code>VirtualAlloc&lt;/code> function form the &lt;code>Kernel32.dll&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-Cpp" data-lang="Cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">LPVOID&lt;/span> &lt;span class="nf">VirtualAlloc&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">optional&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">LPVOID&lt;/span> &lt;span class="n">lpAddress&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">SIZE_T&lt;/span> &lt;span class="n">dwSize&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">DWORD&lt;/span> &lt;span class="n">flAllocationType&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">[&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">DWORD&lt;/span> &lt;span class="n">flProtect&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Additional info: &lt;a class="link" href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc" target="_blank" rel="noopener"
>VirtualAlloc&lt;/a>&lt;/p>
&lt;p>Basically same as the &lt;code>brk&lt;/code> system call from the Unix-like system, but with more options.&lt;/p>
&lt;h4 id="continue-to-talk-about-the-heap">Continue to talk about the Heap
&lt;/h4>&lt;p>Think about all code you write about the heap, all allocated object you want to access, you must have a pointer to the object.&lt;/p>
&lt;p>That&amp;rsquo;s exactly the problem.&lt;/p>
&lt;p>Take a look at the words again:&lt;/p>
&lt;p>All variables you &lt;em>defined&lt;/em> in a function/method is allocated on the &lt;em>STACK&lt;/em>, even non-fixed size types and reference types.&lt;/p>
&lt;p>What you can access directly is Only the pointer, not the object itself. You MUST uses the pointer to access the object. And the pointer is allocated on the stack.&lt;/p>
&lt;p>Note that reference type is basically safe pointer, the reference is allocated on the stack, and the object is allocated on the heap.&lt;/p>
&lt;p>There&amp;rsquo;s still one thing we have to talk about:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-Cpp" data-lang="Cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">vec1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;*&lt;/span> &lt;span class="n">vec2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>What&amp;rsquo;s the difference between the two?&lt;/p>
&lt;p>I want to talk about the implementation and underlying of the &lt;code>vector&lt;/code> first.&lt;/p>
&lt;p>When we talk about the dynamic array, we always have a pointer to the actually array, and the size of the array. So the vector is like this:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C" data-lang="C">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Note that I declared it as a struct, I&amp;#39;ll explain it later
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">Vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">size_t&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">size_t&lt;/span> &lt;span class="n">capacity&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>The first line of the code above actually allocated the three fields on the stack, Pointer to the data, size of the data, and the capacity of the data.&lt;/p>
&lt;p>The second line of the code above actually allocated the three fields on the heap, Pointer to the data, size of the data, and the capacity of the data. And we uses a pointer to access the object.&lt;/p>
&lt;p>Values Allocated in Rust without Smart Pointer were all like the first line of the code above. Which is, All fields allocated on the stack.&lt;/p>
&lt;p>Smart pointer is like the Vector above(actually vector is a smart pointer), it allocates the fields on the stack, including a pointer to the actual object.&lt;/p>
&lt;h4 id="fixed-size">Fixed size?
&lt;/h4>&lt;p>Actually, a class defination determined that class is also fixed size, just like the struct.&lt;/p>
&lt;p>But class has a special feature: &lt;strong>Polymorphism&lt;/strong>.&lt;/p>
&lt;p>That&amp;rsquo;s is, when you reference an class object, it may not be the exactly the type, but a derived type. And derived type may have more fields than the base type. Which means the size of the object is not fixed.&lt;/p>
&lt;h4 id="struct-and-class">Struct and Class
&lt;/h4>&lt;p>Struct instance were allocated on the stack by default, and class instance were allocated on the heap by default.&lt;/p>
&lt;p>Since the struct is allocated on the stack, we Call it &lt;strong>Value Type&lt;/strong>. Value means we are not accessing it by a pointer, reference or something like that. But directly, we can touch it.&lt;/p>
&lt;h5 id="why-i-declared-the-vector-as-a-struct">Why I declared the &lt;code>Vector&lt;/code> as a struct?
&lt;/h5>&lt;p>Simply because C++ allows you allocate a class instance on the stack. And I don&amp;rsquo;t want to make things confusing for people uses other languages.&lt;/p>
&lt;p>although this loses the most important feature of the class: polymorphism, which makes a class like a struct.&lt;/p>
&lt;h4 id="why-all-instances-allocated-on-the-stack-must-be-fixed-size">Why All instances allocated on the stack MUST be fixed size?
&lt;/h4>&lt;p>Allocation calls for Value Types were generated at the the compile time, and the size of the object must be known at the compile time.&lt;/p>
&lt;p>Also, the allocations calls hardcoded the size of the object, which means the size of the object must be fixed.&lt;/p>
&lt;p>Since the class has a special feature: Polymorphism, the size of the object is not fixed, so we can&amp;rsquo;t allocate it on the stack. But without Polymorphism, we can allocate a class instance on the stack, just like C++ does.&lt;/p>
&lt;h5 id="micro-views-of-the-stack">Micro views of the stack
&lt;/h5>&lt;p>I&amp;rsquo;ve talked about where is the heap, but not the stack. Stack is also a contiguous memory block. For simplicity, I&amp;rsquo;ll say that stack were managed by the OS, although it&amp;rsquo;s not true in some cases.&lt;/p>
&lt;p>Stack of a program is Program Stack or Call Stack or Execution Stack. It&amp;rsquo;s used to store the local variables, function parameters, and the return address of the function.&lt;/p>
&lt;p>When a process starts, the OS will allocate a memory block for the process. And make a certain register point to the end of the memory block(High address). This register is called the &lt;strong>Stack Pointer&lt;/strong>, which is &lt;code>rsp&lt;/code> in x86_64 and &lt;code>sp&lt;/code> in RISC-V.&lt;/p>
&lt;p>When you try allocate an instance on the stack, like, a int, we simply minus the stack pointer.&lt;/p>
&lt;p>You might know stack is FILO or LIFO, but that doesn&amp;rsquo;t mean we have to pop the stack if we want to access the inner object. The FILO or LIFO is only for the stack frame, which keeps everything essential to allow function calling/returning.&lt;/p>
&lt;p>Since all instance on the stack is fixed size, all of their position is fixed, we know where the object is at the compile time. We know that all local variables can be accessed by frame pointer plus a fixed offset.&lt;/p>
&lt;p>The stack is array-like, but not a real array. It&amp;rsquo;s a memory block, a memory block means that you can access whatever you want with the memory block. Stack is just a convention which constraints the way we access the memory block - FILO or LIFO.&lt;/p>
&lt;p>An example is that, in Rust, we don&amp;rsquo;t have a specific data structure for Stack. In C++, in python, in .NET you would have a Type like &lt;code>Stack&amp;lt;T&amp;gt;&lt;/code>, but in Rust, we don&amp;rsquo;t have that. We just use &lt;code>Vec&amp;lt;T&amp;gt;&lt;/code>(&lt;code>vector&amp;lt;T&amp;gt;&lt;/code> in Cpp). As long as you only call push and pop method.&lt;/p>
&lt;h6 id="why-the-stack-is-faster-than-the-heap">Why the stack is faster than the heap?
&lt;/h6>&lt;p>When we access the object on the stack, we know where the object is, we access it with a single instruction which contains the frame pointer and the offset.&lt;/p>
&lt;p>But when we access the object on the heap, we have to read the pointer to a register, and then access the object with the pointer. That&amp;rsquo;s two instructions.&lt;/p>
&lt;p>Also, accessing instance on the heap may cause cache miss, which is the REAL reason that heap is slower than the stack.&lt;/p>
&lt;h5 id="micro-views-of-the-stack-allocation">Micro views of the stack allocation
&lt;/h5>&lt;p>Having talked about the stack so much, you might wonder when do we push and pop.&lt;/p>
&lt;p>The name of call stack implied that the stack has strong connection with &lt;em>Fuction Call&lt;/em>.&lt;/p>
&lt;p>You must have seen stack trace when the runtime throw an exception. The stack trace is actually the call stack.&lt;/p>
&lt;p>Stack trace when a exception is thrown in .NET:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Unhandled exception. System.Exception: Exception from Buz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at Program.Buz() in /home/caiyi/loongson-blog/content/post/move-semantic/StackTraceDemo/Program.cs:line 24
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at Program.Bar() in /home/caiyi/loongson-blog/content/post/move-semantic/StackTraceDemo/Program.cs:line 17
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at Program.Foo() in /home/caiyi/loongson-blog/content/post/move-semantic/StackTraceDemo/Program.cs:line 11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at Program.Main(String[] args) in /home/caiyi/loongson-blog/content/post/move-semantic/StackTraceDemo/Program.cs:line 5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Remove some of the information, we get:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> at Program.Buz() in Program.cs:line 24
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at Program.Bar() in Program.cs:line 17
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at Program.Foo() in Program.cs:line 11
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> at Program.Main(String[] args) in Program.cs:line 5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Code can be obtained from &lt;a class="link" href="https://github.com/Loongson-neuq/blog/tree/main/content/post/move-semantic/StackTraceDemo" target="_blank" rel="noopener"
>https://github.com/Loongson-neuq/blog/tree/main/content/post/move-semantic/StackTraceDemo&lt;/a>&lt;/p>
&lt;p>Why do we have so many functions from the Stack trace? Because the functions are called nestedly.&lt;/p>
&lt;p>The top function is where the exception was actually thrown, and the lower function is where the top function was called. Since the main thread of our program begins with &lt;code>Main()&lt;/code> function, the bottom function is always &lt;code>Main()&lt;/code>.&lt;/p>
&lt;p>When a function is called, the runtime will push a new frame to the stack, and when the function returns, the runtime will pop the frame from the stack.&lt;/p>
&lt;p>&lt;strong>A frame stores everyting essential to restore the envrionment before the function was the frame call another function.&lt;/strong>&lt;/p>
&lt;p>We know that CPU must read datas to its own &lt;em>register&lt;/em> to do the calculation, and the register is limited. So we have to store the local variables and other things in somewhere else. That&amp;rsquo;s the stack frame. A frame only stores datas of the function, and the frame is popped when the function returns.&lt;/p>
&lt;h6 id="lets-look-at-some-assembly-code">Let&amp;rsquo;s look at some assembly code
&lt;/h6>&lt;p>Having talked about how the stack so much, you might think it&amp;rsquo;s rather complicated to push and pop the stack. But it&amp;rsquo;s not. As I said before, we only have to minus the stack pointer and the minused size of memory is yours! To return the memory, we only have to add the size to the stack pointer.&lt;/p>
&lt;p>&lt;strong>NO NEED TO CLEAR THE MEMORY when we push/pop the stack. CAN YOU THINK ABOUT WHY?&lt;/strong>&lt;/p>
&lt;p>The same code as the one at the beginning of the article:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-Cpp" data-lang="Cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Object&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">_value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">StructType&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">value1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">value2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">value3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Object&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">obj&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Object&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">str&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;Hello, world&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">StructType&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">StructType&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>The assembly code of the function &lt;code>foo&lt;/code> is like this:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">section .data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">str db &amp;#34;Hello, world&amp;#34;, 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">section .text
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">global foo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">foo:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ; 函数开始，保存栈帧
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> push rbp ; 保存原始栈帧
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov rbp, rsp ; 设置新的栈帧
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ; int i = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov dword ptr [rbp-4], 0 ; 将变量 i 初始化为 0，并保存在栈中偏移 -4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ; int* p = &amp;amp;i;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lea rax, [rbp-4] ; 取得变量 i 的地址
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov qword ptr [rbp-8], rax ; 将 p 指向 i 的地址并保存偏移 -8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ; Object* obj = new Object();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov edi, 4 ; Object 的大小为 4 字节
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> call _Znwm ; 调用 operator new
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov qword ptr [rbp-16], rax ; 保存返回的对象地址到 obj 中（偏移 -16）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ; std::string str = &amp;#34;Hello, world&amp;#34;;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lea rdi, [rel str] ; 将字符串地址加载到 rdi
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lea rsi, [rbp-32] ; 准备 str 变量的栈位置（偏移 -32）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> call _ZNSsC1EPKc ; 调用 std::string 构造函数
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ; StructType value = StructType {1, 2, 3};
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov dword ptr [rbp-48], 1 ; 将 1 存储到 value.value1（偏移 -48）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov dword ptr [rbp-44], 2 ; 将 2 存储到 value.value2（偏移 -44）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov dword ptr [rbp-40], 3 ; 将 3 存储到 value.value3（偏移 -40）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ; 函数结束，恢复栈帧并返回
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> mov rsp, rbp ; 恢复原始栈指针
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pop rbp ; 弹出原始栈帧
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ret ; 返回
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>We even do have to actually DO a allocation operation. We just know that where every variable should be and read/wirte the place directly. See instructions like &lt;code>mov dword ptr [rbp...], ...&lt;/code>&lt;/p>
&lt;p>Additinally, &lt;code>push&lt;/code> and &lt;code>pop&lt;/code> instructions are also used to store/access the stack, but they are just pseduo instructions. The real instructions are &lt;code>mov&lt;/code> and &lt;code>add&lt;/code>.&lt;/p>
&lt;p>From the assembly code, we can see that how much we push/pop the stack is determined at the compile time, hard coded in the assembly instructions. You should know why all value types must be fixed size now.&lt;/p>
&lt;p>Since we only care about current frame, which is at the top of the stack, we don&amp;rsquo;t need to have store the size of every frame, the base of the whole stack, or the end of the stack. We only need to store the stack pointer, which is the top of the stack, or the base of the current frame.&lt;/p>
&lt;p>Then I&amp;rsquo;ll talk about why do we never clean the stack.&lt;/p>
&lt;p>When we pop a frame, the depth of stack just got smaller, and there will be no chance of reading uninitialized data or overwriting the data.&lt;/p>
&lt;p>When we push a frame, we always write the data before we can access it. Remember that the Compiler always say &lt;code>Uninitialized variable&lt;/code> when you try to access a variable before you write it. The compiler gurantee that you will never read uninitialized data at the compile time, so we don&amp;rsquo;t have to clear the memory, which makes function call faster.&lt;/p>
&lt;h3 id="data-inconsistency-issue-in-multi-threaded-scenarios">Data inconsistency issue in Multi-threaded scenarios
&lt;/h3>&lt;p>Watch a demo&lt;/p>
&lt;p>or Download and run yourself&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/Loongson-neuq/blog/tree/main/content/post/move-semantic/MuitlThreadDemo" target="_blank" rel="noopener"
>https://github.com/Loongson-neuq/blog/tree/main/content/post/move-semantic/MuitlThreadDemo&lt;/a>&lt;/p>
&lt;p>Note: You need to have a .NET 8 runtime installed to run the demo. Install it from
&lt;a class="link" href="https://dot.net/download" target="_blank" rel="noopener"
>dot.net&lt;/a>&lt;/p>
&lt;h4 id="lock">Lock
&lt;/h4>&lt;h4 id="read-write-lock">Read-write Lock
&lt;/h4>&lt;p>TODO： Unimplemented&lt;/p>
&lt;h2 id="rust">Rust
&lt;/h2>&lt;p>&lt;strong>WARN: the follow content were generated by ChatGPT&lt;/strong>&lt;/p>
&lt;!-- TODO: Rewrite it -->
&lt;h3 id="understanding-rusts-ownership-and-borrowing-rules-through-the-lens-of-read-write-locks-and-stack-memory-management">Understanding Rust&amp;rsquo;s Ownership and Borrowing Rules through the Lens of Read-Write Locks and Stack Memory Management
&lt;/h3>&lt;p>Rust’s &lt;strong>Single Owner Rule&lt;/strong> and &lt;strong>Single Mutable Reference Rule&lt;/strong> can be better understood when examined through the principles behind &lt;strong>read-write locks&lt;/strong> and &lt;strong>stack-based memory management&lt;/strong>.&lt;/p>
&lt;h4 id="rusts-ownership-and-borrowing-rules-as-a-read-write-lock-analogy">Rust’s Ownership and Borrowing Rules as a Read-Write Lock Analogy
&lt;/h4>&lt;p>In multi-threaded environments, a &lt;strong>read-write lock&lt;/strong> is a synchronization mechanism allowing multiple readers to access a resource simultaneously or granting exclusive access to a single writer. Rust’s ownership and borrowing rules mirror this access control strategy, enforcing exclusive or shared access to data at compile time:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Single Owner Rule&lt;/strong>: Rust’s concept of a single owner aligns with the idea of an &lt;strong>exclusive lock&lt;/strong> on a resource. Only one variable or function can own a piece of data at any point, ensuring exclusive access and avoiding any conflicts in memory access.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Single Mutable Reference Rule&lt;/strong>: This rule is conceptually similar to read-write locks and provides two access states:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Shared, Immutable Access&lt;/strong>: Multiple immutable references (using &lt;code>&amp;amp;T&lt;/code>) to a resource are allowed, resembling the behavior of a read lock.&lt;/li>
&lt;li>&lt;strong>Exclusive, Mutable Access&lt;/strong>: Only one mutable reference (using &lt;code>&amp;amp;mut T&lt;/code>) can exist at any time, akin to a write lock, preventing simultaneous modifications by others and ensuring safe mutation.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>By enforcing these rules, Rust’s compiler performs a static analysis to eliminate race conditions and memory conflicts at compile time, achieving thread safety without the runtime overhead of locks.&lt;/p>
&lt;h4 id="safe-memory-management-with-stack-allocation">Safe Memory Management with Stack Allocation
&lt;/h4>&lt;p>Rust’s ownership rules apply to both &lt;strong>stack&lt;/strong> and &lt;strong>heap memory&lt;/strong> management, maintaining safety and efficiency across both types of allocations:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Stack Memory Management&lt;/strong>: In Rust, variables allocated on the stack are assigned a clear, finite lifecycle determined at compile time, corresponding to the stack’s Last-In-First-Out (LIFO) principle. The ownership system prevents issues like double frees, as the ownership rules guarantee that only the active owner has control over memory deallocation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Heap Memory Management&lt;/strong>: When data is allocated on the heap, Rust’s ownership rules still apply, managing the memory lifecycle through single ownership. Heap memory is controlled by the owning variable, and once the variable goes out of scope, the data is automatically deallocated, freeing developers from the need for manual memory management.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Borrowing rules further ensure that data on the heap avoids race conditions. By allowing multiple immutable references (akin to a read lock) but only one mutable reference (like a write lock), Rust’s system dynamically enforces safety similar to a runtime read-write lock.&lt;/p>
&lt;h4 id="case-study-ownership-and-borrowing-in-action-with-concurrency">Case Study: Ownership and Borrowing in Action with Concurrency
&lt;/h4>&lt;p>To illustrate Rust’s ownership and borrowing in action, let’s consider a simple multithreaded example:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">std&lt;/span>::&lt;span class="n">thread&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="fm">vec!&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// Transfer ownership of `data` to the spawned thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">handle&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">thread&lt;/span>::&lt;span class="n">spawn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">move&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// Mutating `data`, ownership is now exclusively with the new thread.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">});&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">handle&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">unwrap&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// Any attempt to access `data` in the main thread would result in a compilation error,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// as ownership has been transferred.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>In this example, ownership of &lt;code>data&lt;/code> is transferred to the new thread using &lt;code>move&lt;/code>, meaning the main thread no longer has access to it. This model functions similarly to an exclusive lock but relies on ownership transfer rather than explicit locks. Rust’s ownership system enforces access control here without locks, allowing memory allocation to remain efficient while eliminating data races at compile time.&lt;/p>
&lt;h4 id="rusts-advantage-compile-time-lock-like-guarantees">Rust’s Advantage: Compile-Time Lock-Like Guarantees
&lt;/h4>&lt;p>Compared to traditional lock-based synchronization, Rust’s ownership and borrowing rules rely on compile-time checks to ensure memory safety, removing the need for runtime locks. The Rust compiler statically analyzes a variable’s lifecycle and reference status, ensuring memory access safety without runtime overhead, which both boosts memory efficiency and minimizes errors.&lt;/p>
&lt;h3 id="conclusion">Conclusion
&lt;/h3>&lt;p>Rust’s ownership and borrowing model integrates the benefits of read-write locks with stack-based memory management principles. By statically enforcing exclusive or shared access, Rust guarantees thread safety and efficient memory management without the performance costs of locks. This unique approach ensures that concurrent programming in Rust is both efficient and safe by design.&lt;/p></description></item></channel></rss>