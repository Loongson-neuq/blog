[{"content":"用 GitHub 网页端编辑文件 不要在 GitHub 网页端编辑文件！！！否则你会收到下面的警告:\n以及一封邮件：\n我们在将来可能会强制删除你的提交如果你继续在网页端编辑文件。\nls -d ../*/ 题目要求“列出父文件夹的文件夹项”。可能是翻译问题，Directory entry被我直接翻译成文件夹项可能导致大家（当然还有大家的好帮手 chatGPT）产生了误解，应当翻译为目录项更为准确。\nDirectory entry　是指一个文件夹内包含的如文件夹，文件，链接等项，因此只需要ls ..就可以列出父文件夹的目录项。\n补充信息 ls 通过getdents系统调用获取目录项。getdents就是 get directory entries 的缩写。\ngetdents syscall\n环境变量？ 误区 - Where is Environment Variables? 我看到有同学说在 “.bashrc 里修改环境变量”，这种说法是不准确的。\n环境变量是操作系统的一部分，不是某个文件里的内容。.bashrc 是一个 shell 脚本，用于配置 shell 的行为，它会在　Shell 启动时执行。因此你事实上是在 .bashrc 里添加了修改环境变量的命令。\n那到底环境变量是储存在哪儿的呢？ 环境变量是一个与进程绑定的概念。在进程被创建时，操作系统会将环境变量传递给进程。\n操作系统传递环境 在 fork，exec 等系统调用中，操作系统会在进程的地址空间中创建一个环境变量表，然后将父进程的环境变量表复制到子进程的环境变量表中。并在子进程的sp指针后面的某一个位置存放一个指向环境变量表的指针。\n进程接收环境变量 子进程刚开始运行时（在你们熟知的main函数前），会通过 sp 指针构造参数 int argc, char *argv[], char *envp[]。envp 就是指向环境变量表的指针。这三个参数也是 C 语言的标准 main 函数签名的参数。\n某些跨平台语言会对环境变量的接收方式进行封装，因为不同的操作系统可能有不同的实现。不过你仍然可以通过标准库的函数获取环境变量，例如　C# 的 System.Environment.GetEnvironmentVariable() 和 Python 的 os.environ。\nroot 用户的命令提示符 普通用户的 shell 提示符通常是 $ 或 \u0026gt;，而 root 用户的 shell 提示符通常是 #。\n连续创建嵌套文件夹 记得添加 -p 选项。如\n1 mkdir -p top/middle/bottom 重命名 test 文件夹为 test1？ 可能错误的做法：\n1 mv test/ test1/ 正确的做法：\n1 mv test test1 问题？\n1 2 3 4 5 6 7 8 9 10 11 12 13 caiyi@LAPTOP-I80ETG8J /tmp \u0026gt; cd $(mktemp -d) caiyi@LAPTOP-I80ETG8J /t/tmp.mABXKSHACy\u0026gt; mkdir test caiyi@LAPTOP-I80ETG8J /t/tmp.mABXKSHACy\u0026gt; mv test/ test1/ caiyi@LAPTOP-I80ETG8J /t/tmp.mABXKSHACy\u0026gt; ls test1/ caiyi@LAPTOP-I80ETG8J /t/tmp.mABXKSHACy\u0026gt; # test 被重命名 caiyi@LAPTOP-I80ETG8J /t/tmp.mABXKSHACy\u0026gt; mkdir test caiyi@LAPTOP-I80ETG8J /t/tmp.mABXKSHACy\u0026gt; mv test/ test1/ caiyi@LAPTOP-I80ETG8J /t/tmp.mABXKSHACy\u0026gt; ls test1/ caiyi@LAPTOP-I80ETG8J /t/tmp.mABXKSHACy\u0026gt; ls test1/ test/ caiyi@LAPTOP-I80ETG8J /t/tmp.mABXKSHACy\u0026gt; # test 被移动 Fork 仓库再提交？ 课上说\n工作目录问题 课上说\n最后 提醒大家不要过度相信 AI，AI 可能会给出错误的答案。即使 AI 给出了正确答案，你也要自己去理解才能更好地掌握知识。\n有的同学的答案太离谱了，完全就是 AI 生成的答案。题目明明是一张图片，但是直接把 markdown 原文复制给 AI，AI 又看不到图片，就只能回答“这是一张图片”。\n但是并不是反对大家使用 AI，只是要保存怀疑和求证的态度，以及自己的思考能力和学习能力。\n","date":"2024-10-22T00:00:00Z","permalink":"https://loongson-neuq.pages.dev/p/os-week1-%E4%BD%9C%E4%B8%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","title":"[OS Week1] 作业常见问题"},{"content":"Git Installations Windows Download installer from Git For Windows\nor use winget\n1 winget install Git.Git Linux Install with your package manager\nMacOS Install with Homebrew\nConfiguration Global Configuration Detailed instructions: manual.caiyi1.me\n1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;Your Email\u0026#34; Authentication For code hosting services like GitHub, GitLab, Gitee, etc, you have to proof the user pushing(or pull) the code HAS the permission to do so.\nTraditional way is to use SSH key, which is a pair of keys, one is public, one is private. Public key is stored on the server, and private key is stored on your local machine.\n国内平台如 Gitee 只能使用 SSH key 进行认证, 不能使用 credential helper。\nStill widely used, but is outdated. As Git allows custom credential helper, you can use a more secure way(and easier) to authenticate.\nWindows Uses git credential-manager, which is a part of Git for Windows.\nAuth Github 1 git credential-manager github login Follow the GUI instructions to login.\nLinux Auth Github uses GitHub CLI, which is provided by the distro\u0026rsquo;s package manager.\n1 2 # Debian/Ubuntu sudo apt install gh Login with\n1 gh auth login Follow the instructions to login.\nBasic Usage Detailed instructions: manual.caiyi1.me\nInit Clone Commit Push Pull Fetch Linux Basics Linux 不只是一个工具，也可以是像 Windows 一样用于日常工作的操作系统。\nKDE 桌面环境提供与 Windows 类似的体验，几乎没有任何学习成本。\nInstallations Choose a way to install Linux Physical Machine\nFull performance Graphics interface Take up a lot of space May not be easy to install if you are not experienced Recommend for those who want immersive experience WSL2\nEasy to install Extremely low performance cost Disk-friendly Battery-friendly Only Command Line Interface, but you still uses Windows\u0026rsquo; GUI Good integration with Host OS(Windows) Can run Linux GUI applications with X server (although not recommended for performance) Virtual Machine - Really not recommended\nReally low performance Memory unfriendly Battery unfriendly Graphics interface Installation Guide\nWhy Linux Excellent Command Line Interface\nShell 各种命令行工具 丰富的管道命令 丰富的脚本语言，易于自动化 Software Package Management\n无需手动下载安装 依赖自动解决 减少重复软件下载 便于卸载，没有毒瘤软件 Developer-friendly\nEditor Vim/Nvim VSCode \u0026hellip; Compiler GCC Clang \u0026hellip; Cross-platform development\nCMake/Make LLVM，GCC OS 内核需要 cross-compile Highly customizable\nShell Window Manager Desktop Environment \u0026hellip; Open Source\n无需担心软件的安全性 无需担心软件的可用性 无需担心软件的可维护性 无需担心软件的隐私问题 (大多数情况，取决于你的使用方式) Shortcomings Sucks when you need to use Windows-only software Suck graphics driver support (Not for all hardware) Suck graphics backend support X.org Old, and has not been updated for a long time May have some security issues May not support some new features But still widely used Good support for software Wayland Lacks many features Bad support for some software Really HIGH rendering latency You can feel it! Not suitable for latency-sensitive games, like rhythm games Nvidia support sucks Games may run with lower performance Higher power consumption than X.org Modern, updated frequently Trending But I still recommend you to use Wayland as long as you don\u0026rsquo;t have any problems with it.\nUnboxing 以下内容以相对稳定且简单 Ubuntu 22 作为演示。\nPackage Manager Whats Package Manager 包管理器用于管理 GNU/Linux 发行版的包（应用），不同于 Windows 的手动下载并安装，在 Linux 下安装 Git 只用输入一条命令。\n可以通过类比的方式理解包管理器和包：\n左右两项不等价\nWindows Linux 应用商店 包管理器 App 包 大多数 Linux 发行版都有自己的包管理器：\nDebian RPM Pacman apt, dpkg yum, rpm pacman Ubuntu 的包管理器是 apt 和 dpkg，其中 apt 用于安装云端软件源的包，dpkg 则用于安装本地包。\n1 2 apt --version # output: apt 2.4.12 (amd64) Usage 如果遇到了网络问题，请跳转下方 Mirror。\n更新软件包列表 在安装包之前，一般会同步云端软件包信息，保证依赖关系的正确。\n1 sudo apt update 更新所有软件包 1 sudo apt upgrade 安装软件源的包 将 \u0026lt;name\u0026gt; 换成要安装的包名，多个则以空格分隔。\n1 sudo apt install \u0026lt;name\u0026gt; 安装本地 deb 包 安装中可能会提示依赖缺失，应使用 apt 安装缺失的依赖。\n1 sudo dpkg -i /path/to/xxx.deb 卸载包 将 \u0026lt;name\u0026gt; 换成要卸载的包名，多个则以空格分隔。\n1 sudo apt remove \u0026lt;name\u0026gt; 查找包 1 apt search xxx Mirror 在使用 apt 时提示网络错误时，可以通过换源解决。\n修改系统重要文件前记得备份：\n1 2 sudo cp /etc/apt/sources.list /etc/apt/sources.list.back sudo vim /etc/apt/sources.list 在 Ubuntu 24.04 之前，Ubuntu 的软件源配置文件使用传统的 One-Line-Style，路径为 /etc/apt/sources.list；从 Ubuntu 24.04 开始，Ubuntu 的软件源配置文件变更为 DEB822 格式，路径为 /etc/apt/sources.list.d/ubuntu.sources。 参考 https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/\n在文件的顶部加入以下行：\n1 2 3 4 5 6 7 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ noble-backports main restricted universe multiverse 最后更新软件包列表\n1 sudo apt update Install Common Software Pakage for OS Development Git 1 2 sudo apt update sudo apt install git VSCode 以下内容来自 manual\n实体机用户请在 Linux 下安装 VSCode：\n手动安装：\n从 VSCode 官网 下载 deb 包。\n使用 dpkg 安装。\n1 sudo dpkg -i code_xxx.deb 包管理器安装：\n添加源。 1 2 3 4 5 sudo apt-get install wget gpg wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor \u0026gt; packages.microsoft.gpg sudo install -D -o root -g root -m 644 packages.microsoft.gpg /etc/apt/keyrings/packages.microsoft.gpg echo \u0026#34;deb [arch=amd64,arm64,armhf signed-by=/etc/apt/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main\u0026#34; |sudo tee /etc/apt/sources.list.d/vscode.list \u0026gt; /dev/null rm -f packages.microsoft.gpg 安装。 1 2 3 sudo apt install apt-transport-https sudo apt update sudo apt install code # or code-insiders Rust 以下内容源自 rCore-Tutorial-Guide-2024S 文档\n如果遇到网络问题 配置环境变量：\n可以在当前终端执行（当前终端有效），或者写入 ~/.bashrc（永久，打开新的终端后）。\n1 2 export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup 编辑 ~/.cargo/config：\n添加以下行：\n1 2 3 4 5 [source.crates-io] replace-with = \u0026#39;ustc\u0026#39; [source.ustc] registry = \u0026#34;sparse+https://mirrors.ustc.edu.cn/crates.io-index/\u0026#34; 安装 rustup 1 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh QEMU 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 安装依赖 sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \\ gawk build-essential bison flex texinfo gperf libtool patchutils bc \\ zlib1g-dev libexpat-dev pkg-config libglib2.0-dev libpixman-1-dev git tmux python3 # 下载 QEMU 源码 wget https://download.qemu.org/qemu-7.0.0.tar.xz # 解压 tar xvJf qemu-7.0.0.tar.xz # 进入子目录 cd qemu-7.0.0 # 编译安装并配置 RISC-V 支持 ./configure --target-list=riscv64-softmmu,riscv64-linux-user make -j$(nproc) Awesome Tools 为了提高开发效率，推荐部分小工具。\nCLI tools ranger: 文件管理器\nbat: 文件查看器，更好的 less\ntmux: 终端复用器\nlazygit: git TUI 管理工具\neza: 有色彩和图标的 ls\nCommand Line Foreword Shell 是一个解释器，它接受用户输入的命令，然后调用相应的应用程序或内建命令函数。\nWindows\nPowerShell - fairly good, but lack customization. Slow, for still using .NET Framework(capability reasons, but can be replaced by .NET) Update to PowerShell 7, which is cross-platform https://aka.ms/PSWindows CMD Unix-like (inclue Linux, MacOS, FreeBSD\u0026hellip;)\nBash - default, but MUCH better than Windows' Zsh - most popular, maybe hard to configure Fish - easy to use, but not recommended for scripting \u0026hellip; like sh, dash 对于 Unix, 各种 Shell 的语法大致相同，内建命令大多数与 Bash 相同。甚至 Windows 的 PowerShell 也开始为某些 Bash 的内建命令通过 alias 提供支持。\nFish 是一个很好的 Shell，但是不适合用于编写脚本，因为它的语法和其他 Shell 不同。因此建议大家使用 Bash 或者 Zsh。如果你想配置一个好看并且功能强大的 Shell，可以尝试使用 Zsh。\nDetailed instructions: manual.caiyi1.me\nShell script Shell 脚本是一种文本文件，其中包含了一系列的命令（和我们在 shell 前端中输入的一样）。Shell 会按照脚本中的命令顺序执行。\n下面尝试把你输入过的命令写入一个脚本文件，然后执行这个脚本文件。\n1 2 3 pwd echo \u0026#34;----------------\u0026#34; ls 执行时，如果使用./script.sh执行，需要给予执行权限，使用chmod +x script.sh。如果调用 shell 执行，例如bash script.sh，则不需要给予执行权限。\n执行 shell 脚本时，会新开一个 shell 进程执行脚本，因此脚本中的变量不会影响到当前 shell。\n脚本的工作目录与执行脚本的 shell 的工作目录相同。不是脚本文件的目录。\nAdditional: Linux Installation Guide WSL2 Boot up your Windows, enter Microsoft Store, search for \u0026ldquo;WSL\u0026rdquo;, select an distro and install it.\nUbuntu is recommended for beginners as it has official support.\nAfter installation, you can open it from Start Menu or Windows Terminal.\nThe first time you uses it, you have to set up a username and password, not asking for your windows\u0026rsquo;s password.\nPhysical Machine Partition your disk in Windows. You have to create at least two partitions, one for Boot volume, one for Root(Where the system files are stored).\nThe Boot volume should be at least 1GB, and the Root volume should be at least 50GB.\nDownload a distro\u0026rsquo;s ISO file from its official website, and flash it to a USB drive to make a bootable drive.\nReboot your computer to BIOS/UEFI, and boot from the USB drive.\nChoose manual partitioning if you don\u0026rsquo;t want to lose your data and Windows.\nAssign the Boot volume to /boot, and the Root volume to /.\nChoose the boot volume to be formatted as FAT32, and the root volume to be formatted as ext4 or Btrfs.\nAfter installation, you can shutdown your computer and unplug the USB drive.\n##MUST READ## You may lose the ability to boot into Windows, as the bootloader is replaced by the Linux bootloader.\nYou can either select the system to boot in the BIOS/UEFI, or use a bootloader like GRUB/rEFInd.\nNote that GRUB can NOT detect bootable devices at runtime while rEFInd can.\nVirtual Machine Download a distro\u0026rsquo;s ISO file from its official website, and create a new VM in your VM software. Assign at least 50GB of disk space and 4GB of RAM.\nMount the ISO file to the VM, and boot from it.\nInstall the system following the instructions along the way.\nYou can choose \u0026ldquo;Clean Install\u0026rdquo; since we don\u0026rsquo;t have any data to lose.\nAfter installation, you can shutdown the VM and unmount the ISO file. Then you can boot into the system.\n","date":"2024-10-19T00:00:00Z","image":"https://loongson-neuq.pages.dev/p/os-week1-git-and-linux-basics/background_hub7bd9424949445f7cb4edac68fee9448_2942088_120x120_fill_box_smart1_3.png","permalink":"https://loongson-neuq.pages.dev/p/os-week1-git-and-linux-basics/","title":"[OS Week1] Git and Linux Basics"},{"content":"下载安装包 百度搜索vivado，找到\u0026quot;下载 - Xilinx\u0026quot;，进入vivado下载页面\n选择2023.2版本，下载链接\n下载Windows环境下的在线安装器（Windows Self Extracting Web Installer）\n下载需要登陆AMD。如果已有AMD账户直接填写用户名和密码登陆，如果没有账户则点“Create account”免费创建一个新账户。 点击链接后会要求输入个人信息，随便填即可。 如果在线安装器下载不下来 在线安装 双击运行已下载的可执行文件FPGAs_AdaptiveSoCs_Unified_2023.2_1013_2256_Win64.exe。（使用管理员权限，允许网络访问）\n如果弹出更新窗口，点击“continue”。\n点击“Next”。\n登录下载时注册的AMD账号，点击“Next”。\n选择“vivado”，点击“Next”。\n选择免费的标准版，点击“Next”。\n在“Device”中必勾选“Artix-7”，因为开发板搭载的FPGA是Artix-7，其他器件可以根据需要进行选择，“Design Tools”和“Installation Options”按照默认即可。\n全部“I agree”，点击“Next”。\n选择Vivado安装目录，默认安装在“C:\\Xilinx”下，可以点击浏览或者直接更改路径，注意安装路径中不能出现中文和空格。点击“Next”。\n我由于安装过了，显示和大家不一样。\n查看summary，点击“install”。\n等待安装完成。\n问题 不同版本间的编译逻辑可能有所不同，可能会导致不可预知的差异，我们建议使用比赛指定的23.2版本 注意安装路径不要有中文和空格！包括后续项目文件路径中都不能出现中文和空格！！！ 如果你的用户名不幸的有中文的话，STFW改成英文的吧，不然会有更多奇奇怪怪的bug 如果在线安装器有网络问题的话，尝试关闭魔法多试几次，实在不行使用完整的安装包选择本地安装（官网103GB的版本）。 与代码编辑器的联动 VIVADO使用vscode实现实时纠错与自动补全等功能_vivado代码自动对齐_fujiayu1997zz的博客-CSDN博客 Sublime与Verilog【一】：从安装到使用，提高FPGA开发效率！ - 知乎 (zhihu.com) ","date":"2024-10-18T00:00:00Z","permalink":"https://loongson-neuq.pages.dev/p/vivado-2023.2%E5%AE%89%E8%A3%85/","title":"vivado 2023.2安装"},{"content":" 缘起 进入本世纪，移动互联网、大数据、云计算、物联网、人工智能等新一代信息技术快速发展，促进形成了不同形态的新型计算系统。计算机人才的培养从“程序性开发能力”进化为更重要的“系统性设计能力”。要求计算系统开发人员必须了解不同系统平台的底层结构，具有系统观和系统思维，能够进行软硬件协同设计及其贯通，以强大的系统平台技术保证各项应用功能的实现，成为能力的关键特性，即计算机系统能力。计算机系统能力培养对于解决计算机领域卡脖子关键问题，培育我国高端芯片、关键基础软件的后备人才尤为紧迫和重要。\n为此，2019年5月，教育部高等学校计算机类专业教学指导委员会授予我校计算机系统能力培养试点高校。我校正式开始计算机系统能力培养试点建设。2019年6月，我校与龙芯建立深度合作关系并签署了框架合作协议，与龙芯中科有限公司合作，成立龙芯华北基地暨龙芯-东北大学（秦皇岛）联合实验室。旨在培养计算机系统能力，以及为我国培养在卡脖子的计算机核心关键技术领域人才。2019年8月，创立龙芯班，主要培养中央处理器（CPU）、操作系统（OS）、编译器（Compiler），以及嵌入式芯片与系统设计等等。\n计算机系统能力竞赛 全国大学生计算机系统能力大赛旨在以学科竞赛推动专业建设和计算机领域创新人才培养体系改革，培育我国高端芯片、关键基础软件的后备人才，始终坚持围绕CPU、编译系统、操作系统、数据库管理系统的设计和实现，在赛题和赛制上不断推陈出新。2024年启动智能系统创新设计赛（小米杯）、智能计算创新设计赛（先导杯），形成了从计算机系统核心软硬件到完整系统的比赛格局。\n作为“计算机类专业系统能力培养”教育生态的重要组成部分，大赛创办八年来，参赛学校、参赛人数不断增加，以赛促学、以赛促教的作用明显，学生的专业核心能力、工程能力、创新能力不断提升，2023年更是成功入选中国高等教育学会《2023全国普通高校大学生竞赛分析报告》竞赛目录，成为计算机领域重要的学科竞赛。\n2024年，多家新闻媒体对赛事报道。钱江晚报，澎湃新闻网等媒体以“继ACM后，计算机系统能力大赛受众多互联网大厂热捧，为啥？”为标题对赛事进行报道。诸多互联网大厂越来越重视CPU，操作系统、编译器等自主化，它们也将目光投到大学系统人才培养上来。它们通过冠名全国大学生系统能力大赛，比如CPU大赛由“龙芯”冠名，编译系统设计赛由华为“毕昇”冠名，智能系统创新设计赛由“小米”冠名，以提前参与到大学系统设计开发人才培养中来。操作系统功能赛由华为、麒麟、龙芯、蚂蚁、OPPO、vivo、小米、龙蜥社区、国科环宇、飞腾等企业专家命题，吸引350支队伍报名，涉及863名同学和159位指导教师。“华为、龙芯等把它们公司的实际科技问题，拿到了比赛当中，看看在校大学生们怎么解决行业前沿问题，真正体现了业界需求和高校人才培养的‘双向奔赴’。\n目标与规划 以培养学员融会贯通计算机系统的软硬件知识，设计出自己的CPU，并在上面运行自己的操作系统，还在上面运行自己的编译器和数据库等系统软件为目标的龙芯班。\n目前，主要面向龙芯班学员开设两门公选课程《CPU设计艺术》和《操作系统》。其中，《CPU设计艺术》课程将于秋季学期十一后开课，《操作系统》将于春季学期开课。\n选拔龙芯班的优秀学员参加全国计算机系统能力竞赛，力争取得优异成绩。\n选拔龙芯班的优秀学员作为助教团队，辅导新学员学习。\n鼓励优秀学员，参加科创课题团队，一生一芯计划和百芯计划等活动，进一步树立投身科技事业的理想和锻炼能力。\n指导教师 方淼，男，东北大学计算机科学与技术专业工学学士学位，大连理工大学计算机应用技术专业工学博士学位，现任计算机工程系副主任（负责本部门教学工作），学院科研团队“语言与智能系统实验室”负责人，学院“计算机系统能力培养实验班（龙芯实验室）”负责人。目前主要从事自然语言理解，机器学习和计算机系统等方向的科研和教学工作。\n王鑫，男，1978年10月生，河北丰南人，东北大学计算机应用技术工学硕士学位，现任教于计算机科学系计算机科学与技术专业，讲师，主要从事教学工作。负责操作系统教学。\n张旭，女，1988年4月出生，河北迁西人，内蒙古大学计算机专业工学硕士学位，现任教于学院实验教学中心，实验师。目前主要从事实验教学工作，指导学生参加2019年（第12届）中国大学生计算机设计大赛软件应用与开发类决赛（作品：基于网络通信的远程解锁工具）荣获全国二等奖。负责CPU设计教学。\n科创课题指导教师暂未列出。\n优秀学员 Photo Profile 孟祥东，2017级，毕业进入龙芯公司基础软件部工作 杨兆鑫，2017级，考入中科院计算所龙芯实验室研究生 陈虹胜，2019级，毕业进入龙芯公司从事研发工作 宋雨，2018级，毕业考入中科大先进研究院，现加入龙芯实验室从事研究工作 田宇，2018级，毕业考入中科大先进研究院，现加入龙芯实验室从事研究工作 付震宇，2019级，保送到中科大 USTC 解博元，2020级，因竞赛优异成绩被华为免试录取 取得成绩 2020年，我校首次入围CPU赛道全国总决赛，荣获团队赛三等奖一项和个人赛三等奖一项。\n2021年，我校再创佳绩，在CPU赛道全国总决赛，获得团队赛三等奖两项，个人赛二等奖一项。\n2022年，我校继续入围CPU赛道全国总决赛，团队赛三等奖一项，个人赛三等奖一项。\n2023年，我们在全国总决赛CPU赛道获得团队赛三等奖两项，在OS赛道，获得团队赛三等奖一项，优胜奖一项。\n2024年，我们在全国总决赛智能系统创新设计赛道获得团队赛一等奖，在CPU赛道获得团队赛二等奖两项，在OS赛道，获得团队赛三等奖一项。\n召唤 如果你有梦想，想设计自己的CPU，运行自己的OS，安装自己设计的编译器，请加入我们！ 如果你有梦想，想在大学期间做一款自己的CPU产品，流出一块自己的芯片，请加入我们！ 如果你有梦想，掌握计算机领域核心技术，到计算机系统能力大赛舞台展现实力，毕业到大厂工作，请加入我们！ 如果你有梦想，希望掌握计算机核心技术，为科技强国做出自己的贡献，请加入我们！ 加入我们，开启你的技术进阶之旅！与志同道合的伙伴一起，探索前沿技术，成就你的未来梦想！ 强烈呼唤各位的到来，独行者速，众行者远！ 报名要求：\n热爱计算机系统和CPU、OS、Compiler设计，有志为国家计算机事业发展做贡献； 积极主动、坚持不懈，有较强的团队责任心和自学能力； 大一、大二，以及大三学生（能专心做芯片设计毕设，工作非考研的同学）。 招生规模：暂定为不超过60人\n开班日期：十一假期后\n报名截止日期： 2024年10月9号 24:00\n加入招新群：231607730\n联系人：\n白聪（OS方向）： QQ：1561331574，邮箱：1561331574@qq.com\n杨欣蕊（CPU方向）：QQ：1010191094，邮箱：1010191094@qq.com\n地点：基础楼304\n","date":"2024-09-28T16:51:51+08:00","permalink":"https://loongson-neuq.pages.dev/p/loongson-lab/","title":"Loongson-Lab"},{"content":"假设你需要连续完成某个相同操作 2 次时，你可能这样写代码：\n1 2 Foo(); Foo(); 通常情况下你都会这样做，而不是使用一个 for loop。\n当这个此时大于或等于 10 次时，你大概就不会一个一个写了，而是使用　for 循环。\n然而，如果你稍微思考一下，你都知道：\n1 2 3 4 Foo(); Foo(); Foo(); // 省略 99997 条 Foo　call。 与\n1 2 3 4 for (ulong i = 0; i \u0026lt; 100_000; i++) { Foo(); } 并不完全等价。\n让我们以 CPU 的视角审视一下这个过程：\n对于第一个版本，就完全是 100, 000 条 call 指令。\n对于第二个版本，来说则是\n1 2 3 4 5 6 7 8 9 设置寄存器　i = 0 // xor rcx, rcx, rcx .loop_begin 判断 i 是否小于 100, 000， 如果不是就跳转　.exit_loop // cmp rcx, 100000　\u0026amp;\u0026amp; jge label 调用 Foo 函数　// call Foo 自增索引寄存器 // inc rcx 回到循环开始 // jmp .loop_begin .exit_loop 这两个版本各有各的优势以及缺陷：\n对于第一个版本：\n完成所有任务将执行 100, 000 条指令 所有指令也将占用 100, 000 * 4 字节的内存 对于第二个版本：\n完成所有任务将执行大约 100，000 * 6 条指令 所有指令仅占用　6 * 4 字节的内存 从性能上讲，第一个版本少执行大量指令，意味着更高的性能。但是从内存占用上讲，第一个版本将消耗大量内存，意味着更大的二进制可执行文件。详细可以看最后一节\n思考 那我们能否找到一个平衡点，即，损失一点内存占用，但是提高性能？\n不难发现，第二个版本的性能损失来自于每次循环中的以下部分：\n判断循环索引寄存器 自增循环索引寄存器 跳转 label 因此，我们的任务便是减少这三条指令的执行次数。那么如何减少呢？\n答案非常简单，让我们按照第一个版本的代码，在循环体中多次调用 Foo()。这样，我们就可以减少循环次数，也就减少了额外的指令开销。\n例如，我们可以按照以下方式改写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 循环次数变成了原来的 1/10 for (ulong i = 0; i \u0026lt; 10_000; i++) { // 循环一次执行十条 call Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); } 这下，我们只需要执行大约 10_000 * 5 + 100_000 条指令，以及大幅减少了执行指令的条数。\n这个过程就是循环优化。大部分编译器都支持这种优化。\n问题 循环优化好是好，但是事情并不总是这么美好。当循环次数不是展开倍率的整数倍时，我们需要在循环完成后再手动执行。当循环次数不是常量时，就更麻烦了！\n要实现一个对于任意给定循环次数 n 都能够正确执行的循环展开，我们可以使用以下代码来实现：\n注意我切换成了 C 语言，这是为了给后面的达夫设备埋下伏笔\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void task(int n) { const int UNROLL_COUNT = 10; size_t loop_count = (n + UNROLL_COUNT - 1) / UNROLL_COUNT; for (size_t i = 0; i \u0026lt; loop_count; i++) { foo(); foo(); foo(); // 省略 7 行 } // 执行剩余的次数 switch (n % UNROLL_COUNT) { case 9: foo(); case 8: foo(); case 7: foo(); case 6: foo(); case 5: foo(); case 4: foo(); case 3: foo(); case 2: foo(); case 1: foo(); } } 达夫设备 我猜大部分人都会这样写，虽然可能会有一些小区别。然而 Tom Duff 给出了一个估计只有外星人才能一眼看明白的解法1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void task(int count) { register count; { register n = (count + 7) / 8; switch(count % 8) { case 0: do{ foo(); case 7: foo(); case 6: foo(); case 5: foo(); case 4: foo(); case 3: foo(); case 2: foo(); case 1: foo(); } while (--n \u0026gt; 0); } } } 我特意关闭了语法高亮。一眼看上去，这 tm 是人能写出来的？你大概甚至很难相信这个代码能够通过编译。但它确实可以，并且据 Tom Duff 所说，它运行得很好1。\n我这里给出我直译的版本。尽管仍有一点区别，但是这个区别正是达夫设备的价值所在。\n直译版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void task(int count) { register count; { register n = (count + 7) / 8; switch(count % 8) { case 0: goto .remainder_is_0; case 7: goto .remainder_is_7; case 6: goto .remainder_is_6; case 5: goto .remainder_is_5; case 4: goto .remainder_is_4; case 3: goto .remainder_is_3; case 2: goto .remainder_is_2; case 1: goto .remainder_is_1; } do { .remainder_is_0: foo(); .remainder_is_1: foo(); .remainder_is_2: foo(); .remainder_is_3: foo(); .remainder_is_4: foo(); .remainder_is_5: foo(); .remainder_is_6: foo(); .remainder_is_7: foo(); } while(--n \u0026gt; 0); } } 当刚进入函数时，会先计算余数，并根据余数跳转到循环体内部，先执行相应次数的 foo()。接着，将会开始 do-while 循环，通过循环的方式执行剩下的次数。\n当我们仅考虑 foo() 的执行情况，我们可以得出以下版本的代码。\n意译版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void task(int count) { register count; { register n = (count + 7) / 8; switch(count % 8) { case 0: foo(); case 7: foo(); case 6: foo(); case 5: foo(); case 4: foo(); case 3: foo(); case 2: foo(); case 1: foo(); } do { foo(); foo(); foo(); foo(); foo(); foo(); foo(); foo(); } while(--n \u0026gt; 0); } } 这个版本的代码仅用于你了解这个过程中发生了什么。让我们回到上面直译版的代码。\n我前面提到，直译版的代码于 Tom Duff 给出的版本仍有一点区别。这个区别就是，我在 switch 语句的各个 case 中又使用　goto　跳转到了对应的位置，但是 Tom Duff 直接利用了 switch 语句跳转到了对应的部分。\n在这个过程中，每一个 case 就像 label 一样仅用于标识指令的地址而不影响 switch 语句内部其他的语句的语义，也不影响内部的控制流。\n达夫设备的性能 从性能上讲，达夫设备与我们编写的循环展开或者上面的意译版性能相同。不过，达夫设备并不总是在所有情况下提供最高性能（假设循环展开次数相同）。你可以查看 达夫设备 - 维基百科 了解更多。\n达夫设备应用？ 那么这个“特性”有什么作用呢？\nPuTTY 的作者使用这种特性，在 C 语言中实现了不改变代码控制流的情况下的无栈协程。\n通常来说，对于这样的协程方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static IEnumerable\u0026lt;int\u0026gt; Fib() { int prev = 0, next = 1; yield return prev; yield return next; while (true) { int sum = prev + next; yield return sum; prev = next; next = sum; } } 会被编译成一个完全状态机：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public static IEnumerable\u0026lt;int\u0026gt; Fib() =\u0026gt; new FibStateMachine(-2); [CompilerGenerated] private sealed class FibStateMachine : IEnumerable\u0026lt;int\u0026gt;, IEnumerable, IEnumerator\u0026lt;int\u0026gt;, IEnumerator, IDisposable { private int state; private int current; private int prev; private int next; private int sum; int IEnumerator\u0026lt;int\u0026gt;.Current =\u0026gt; this.current; object IEnumerator.Current =\u0026gt; this.current; public FibStateMachine(int state) =\u0026gt; this.state = state; private bool MoveNext() { switch (this.state) { default: return false; case 0: this.state = -1; this.prev = 0; this.next = 1; this.current = this.prev; this.state = 1; return true; case 1: this.state = -1; this.current = this.next; this.state = 2; return true; case 2: this.state = -1; break; case 3: this.state = -1; this.prev = this.next; this.next = this.sum; break; } this.sum = this.prev + this.next; this.current = this.sum; this.state = 3; return true; } IEnumerator\u0026lt;int\u0026gt; IEnumerable\u0026lt;int\u0026gt;.GetEnumerator() { if (this.state == -2) { this.state = 0; return this; } return new FibStateMachine(0); } IEnumerator IEnumerable.GetEnumerator() =\u0026gt; ((IEnumerable\u0026lt;int\u0026gt;)this).GetEnumerator(); void IEnumerator.Reset() =\u0026gt; throw new NotSupportedException(); void IDisposable.Dispose() { } } 可以看到，方法的控制流被编译器完全改变，因为每一个 yield return 语句都意味着下一次进入函数时要从一个新的状态开始继续运行。不仅如此，原有方法现在仅仅返回一个新的状态机对象，而不包含任何实现。这意味着，在原方法中，不改变控制流的情况下很难实现协程效果。\nSimon Tatham 利用达夫设备和宏，在 C 语言中，仅需插入少许代码即可实现无栈协程！就像我在前面给出的 C# 版本的协程一样。你一眼就能理解修改后的协程方法的控制流。\n你可以点击以下链接进行了解\n原文（英语） 译文（站外链接） 然而 Simon Tatham 的无栈协程也仅仅能存在于理论中，并且他给出的代码使用全局变量来保存协程上下文，因此不能同时调用同一个协程方法。而且，就像 Simon Tatham 在最后说的一样，这些“可怕破坏性的 crReturn 宏”，“非常糟糕的清晰度”以及“难如登天的重写复杂度”都阻止你在任何场合使用它。\n不过在了解这些原理的过程中，你的能力又提升了不少，不是吗？\n循环展开的性能 让我们回到文章一开始的三个代码片段。\n并非第一个版本的性能就是第二个版本的 1/6，由于存在大量指令，CPU 取指令同样消耗时间，并且这是一个相对耗时的任务。CPU 也具有分支预测等优化技巧来减少每次条件判断的耗时。并且在这种情况下，分支预测通常有较高的正确率。\n同时，Foo 内部的实现也影响执行效率的倍率。当 Foo 内部的实现越复杂，指令越多，循环所导致的性能缺陷就越不明显。\n因此，当你实际 Benchmark 这两段代码时，可能并不会有那么可观的差距。\n我使用以下代码进行 Benchmark：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class BenchmarkLoopUnroll { [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)] public static void Foo() { } [Benchmark] [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.AggressiveOptimization)] public void ForLoopCompilerOptimized() { for (int i = 0; i \u0026lt; 1000; i++) { Foo(); } } [Benchmark] [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)] public void ForLoop10TimesUnroll() { for (int i = 0; i \u0026lt; 100; i++) { Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); Foo(); } } [Benchmark] [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)] public void ForLoopNoOptimization() { for (int i = 0; i \u0026lt; 1000; i++) { Foo(); } } [Benchmark(Baseline = true)] [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)] public void HardCodedThousandCall() { Foo(); Foo(); Foo(); // 省略 997 行 } } 使用 RyuJIT 得到以下测试结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // * Summary * BenchmarkDotNet v0.14.0, Ubuntu 24.04 LTS (Noble Numbat) WSL 13th Gen Intel Core i5-13500H, 1 CPU, 16 logical and 8 physical cores .NET SDK 8.0.108 [Host] : .NET 8.0.8 (8.0.824.36612), X64 RyuJIT AVX2 DefaultJob : .NET 8.0.8 (8.0.824.36612), X64 RyuJIT AVX2 | Method | Mean | Error | StdDev | Ratio | RatioSD | |------------------------- |---------:|----------:|----------:|------:|--------:| | HardCodedThousandCall | 1.095 us | 0.0129 us | 0.0120 us | 1.00 | 0.02 | | ForLoopNoOptimization | 1.110 us | 0.0211 us | 0.0187 us | 1.01 | 0.02 | | ForLoop10TimesUnroll | 1.050 us | 0.0193 us | 0.0180 us | 0.96 | 0.02 | | ForLoopCompilerOptimized | 1.070 us | 0.0117 us | 0.0109 us | 0.98 | 0.01 | // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Ratio : Mean of the ratio distribution ([Current]/[Baseline]) RatioSD : Standard deviation of the ratio distribution ([Current]/[Baseline]) 1 us : 1 Microsecond (0.000001 sec) // ***** BenchmarkRunner: End ***** Run time: 00:00:59 (59.07 sec), executed benchmarks: 4 可以看到，ForLoopNoOptimization 相较于 HardCodedThousandCall 并没有慢很多，虽然确实慢了一些。不过我们手动展开的方法 ForLoop10TimesUnroll 确实是有效的，并且比编译器自带的优化效果还要好。\n作者: Caiyi Shyu Email: caiyishyu@outlook.com https://swtch.com/duffs-device/td-1983.txt\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-09-25T16:18:43+08:00","permalink":"https://loongson-neuq.pages.dev/p/%E4%BB%8E%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80%E5%88%B0%E8%BE%BE%E5%A4%AB%E8%AE%BE%E5%A4%87/","title":"从循环展开到达夫设备"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://loongson-neuq.pages.dev/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Math Typesetting Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ Inline Shortcodes For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\nImage gallery Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-24T00:00:00Z","permalink":"https://loongson-neuq.pages.dev/p/hugos-markdown-extension-usages/","title":"Hugo's markdown extension usages"}]