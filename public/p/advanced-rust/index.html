<!doctype html><html lang=zh-CN dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="What the fuck is Move Semantic, Ownership and Borrowing rule"><title>Advanced Rust</title>
<link rel=canonical href=https://loongson-neuq.pages.dev/p/advanced-rust/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Advanced Rust"><meta property='og:description' content="What the fuck is Move Semantic, Ownership and Borrowing rule"><meta property='og:url' content='https://loongson-neuq.pages.dev/p/advanced-rust/'><meta property='og:site_name' content='NEUQ 龙芯实验室博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Rust'><meta property='article:published_time' content='2024-10-25T00:00:00+00:00'><meta property='article:modified_time' content='2024-10-25T00:00:00+00:00'><meta name=twitter:title content="Advanced Rust"><meta name=twitter:description content="What the fuck is Move Semantic, Ownership and Borrowing rule"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu27a039529b0e16f185ca51fbed76013f_26164_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>NEUQ 龙芯实验室博客</a></h1><h2 class=site-description></h2></div></header><ol class=menu-social><li><a href=https://github.com/Loongson-neuq/blog target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/intro/><span>龙芯班介绍及招新宣传</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#prerequisite>Prerequisite</a><ol><li><a href=#memory-management>Memory Management</a><ol><li><a href=#stack>Stack</a></li><li><a href=#heap>Heap</a></li><li><a href=#continue-to-talk-about-the-heap>Continue to talk about the Heap</a></li><li><a href=#fixed-size>Fixed size?</a></li><li><a href=#struct-and-class>Struct and Class</a></li><li><a href=#why-all-instances-allocated-on-the-stack-must-be-fixed-size>Why All instances allocated on the stack MUST be fixed size?</a></li></ol></li><li><a href=#data-inconsistency-issue-in-multi-threaded-scenarios>Data inconsistency issue in Multi-threaded scenarios</a><ol><li><a href=#lock>Lock</a></li><li><a href=#read-write-lock>Read-write Lock</a></li></ol></li></ol></li><li><a href=#rust>Rust</a><ol><li><a href=#understanding-rusts-ownership-and-borrowing-rules-through-the-lens-of-read-write-locks-and-stack-memory-management>Understanding Rust&rsquo;s Ownership and Borrowing Rules through the Lens of Read-Write Locks and Stack Memory Management</a><ol><li><a href=#rusts-ownership-and-borrowing-rules-as-a-read-write-lock-analogy>Rust’s Ownership and Borrowing Rules as a Read-Write Lock Analogy</a></li><li><a href=#safe-memory-management-with-stack-allocation>Safe Memory Management with Stack Allocation</a></li><li><a href=#case-study-ownership-and-borrowing-in-action-with-concurrency>Case Study: Ownership and Borrowing in Action with Concurrency</a></li><li><a href=#rusts-advantage-compile-time-lock-like-guarantees>Rust’s Advantage: Compile-Time Lock-Like Guarantees</a></li></ol></li><li><a href=#conclusion>Conclusion</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/os/>OS
</a><a href=/categories/%E8%AF%BE%E7%A8%8B/>课程
</a><a href=/categories/rust/>Rust</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/advanced-rust/>Advanced Rust</a></h2><h3 class=article-subtitle>What the fuck is Move Semantic, Ownership and Borrowing rule</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 25, 2024</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 8 分钟</time></div></footer></div></header><section class=article-content><h2 id=prerequisite>Prerequisite</h2><h3 id=memory-management>Memory Management</h3><h4 id=stack>Stack</h4><p>Remember:</p><p>All variables you <em>defined</em> in a function/method is allocated on the <em>STACK</em>, even non-fixed size types and reference types.</p><p>But the thing you can <em>access</em> directly or actually stored on the stack must be fixed size types.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Cpp data-lang=Cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Object</span><span class=o>*</span> <span class=n>obj</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>str</span> <span class=o>=</span> <span class=s>&#34;Hello, world&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>StructType</span> <span class=n>value</span> <span class=o>=</span> <span class=n>StructType</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>All variable you can use directly is allocated on the stack (frame).</p><h5 id=this-is-not-what-i-heard-from-othersthe-internet>This is not what I heard from others/the Internet!</h5><ul><li>Reference types</li><li>String</li><li>Vector<t></li><li>Dynamic allocation (eg. malloc)</li></ul><p>People all told me that these types are allocated on the HEAP!</p><p>I would say, that&rsquo;s the root of your confusion. Why don&rsquo;t we talk about the Heap first then?</p><p>And I used two different term: <code>define</code> and <code>access</code></p><h4 id=heap>Heap</h4><p>Heap is a large contigous memory managed by both the <strong>Operating System</strong> and <strong>the language runtime</strong>.</p><p>Runtime may be the <strong>Standard library</strong>, eg. the libC
or <em>GC</em>, eg. Go, .NET &mldr;</p><p>We don&rsquo;t have to care about what&rsquo;s happening in the background, at least for now.</p><p>We only care about two functions:</p><ol><li>One for alloacting memory</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>alloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>size_of_bytes</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>which is <code>malloc</code>, <code>new</code>, <code>new[]</code> &mldr;</p><ol start=2><li>Another for returning allocated memory</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>free</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>which is <code>free</code>, <code>delete</code>, <code>delete[]</code> &mldr;</p><p>One interesting thing you should have noticed is, when we returning a piece of memory, we only need to pass the pointer to the function, but not the size of the memory.</p><p>Why? Because <em>Someone</em> must have recorded the size of the memory when it was allocated.</p><p>The guy is the <strong>Memory Allocator</strong>, a part of the runtime.</p><p>When you call alloc method, the allocator simply find a piece of memory that is large enough to hold the data you want to store, and then record the size of the memory.</p><p>But where is the large piece of meory(the allocator uses) from?</p><p>The answer is the <strong>Operating System</strong>.</p><p>The OS provides a system call to allocate a piece of memory, and the allocator will use this system call to get the memory.</p><h5 id=unix-like-system>Unix-like system</h5><p>The unix-like system provides a system call <code>brk</code> or <code>sbrk</code> to allocate memory.</p><p>The system call is like the function below, but is NOT a real function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=nf>brk</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>sbrk</span><span class=p>(</span><span class=kt>intptr_t</span> <span class=n>increment</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Additional info: <a class=link href=https://www.man7.org/linux/man-pages/man2/brk.2.html target=_blank rel=noopener>brk syscall</a></p><p>A note from the page:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=nx>Avoid</span> <span class=nx>using</span> <span class=nf>brk</span><span class=p>()</span> <span class=nx>and</span> <span class=nf>sbrk</span><span class=p>():</span> <span class=nx>the</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=nx>memory</span> <span class=nx>allocation</span>
</span></span><span class=line><span class=cl>    <span class=kn>package</span> <span class=nx>is</span> <span class=nx>the</span> <span class=nx>portable</span> <span class=nx>and</span> <span class=nx>comfortable</span> <span class=nx>way</span> <span class=nx>of</span> <span class=nx>allocating</span> <span class=nx>memory</span><span class=p>.</span>
</span></span></code></pre></td></tr></table></div></div><p>When you call the brk, the OS will allocate memories Right After the end of the previous memory block. So when you constently call the brk, the memory block will grow larger and larger, but the memory block is always contiguous.</p><p>The <code>malloc</code> function will use the <code>brk</code> system call to allocate memory, and uses the memory block for the allocation and recording the size of the memory.</p><p>How do the OS gurantee the memory block is contiguous or the end of the memory block always have enough space for the next allocation?</p><p>The answer is, the OS atually doesn&rsquo;t gurantee that. Actually, memory pieces that a user program feels contiguous may <em>NOT</em> be contiguous in the physical memory. The OS uses a technique called <strong>Virtual Memory</strong> and <strong>Page Table</strong> to make the memory block contiguous in the user program&rsquo;s view.</p><p>The OS simply maps the virtual memory to the physical memory. This technique is done with the help of hardwares like MMU, a part of the CPU.</p><h5 id=windows>Windows</h5><p>Windows does basically the same thing, but with a different system call, and the system call is wrapped by the <code>VirtualAlloc</code> function form the <code>Kernel32.dll</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Cpp data-lang=Cpp><span class=line><span class=cl><span class=n>LPVOID</span> <span class=nf>VirtualAlloc</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span> <span class=n>LPVOID</span> <span class=n>lpAddress</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>           <span class=n>SIZE_T</span> <span class=n>dwSize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>           <span class=n>DWORD</span>  <span class=n>flAllocationType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>           <span class=n>DWORD</span>  <span class=n>flProtect</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>Additional info: <a class=link href=https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc target=_blank rel=noopener>VirtualAlloc</a></p><p>Basically same as the <code>brk</code> system call from the Unix-like system, but with more options.</p><h4 id=continue-to-talk-about-the-heap>Continue to talk about the Heap</h4><p>Think about all code you write about the heap, all allocated object you want to access, you must have a pointer to the object.</p><p>That&rsquo;s exactly the problem.</p><p>Take a look at the words again:</p><p>All variables you <em>defined</em> in a function/method is allocated on the <em>STACK</em>, even non-fixed size types and reference types.</p><p>What you can access directly is Only the pointer, not the object itself. You MUST uses the pointer to access the object. And the pointer is allocated on the stack.</p><p>Note that reference type is basically safe pointer, the reference is allocated on the stack, and the object is allocated on the heap.</p><p>There&rsquo;s still one thing we have to talk about:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Cpp data-lang=Cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;*</span> <span class=n>vec2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>What&rsquo;s the difference between the two?</p><p>I want to talk about the implementation and underlying of the <code>vector</code> first.</p><p>When we talk about the dynamic array, we always have a pointer to the actually array, and the size of the array. So the vector is like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// Note that I declared it as a struct, I&#39;ll explain it later
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>Vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The first line of the code above actually allocated the three fields on the stack, Pointer to the data, size of the data, and the capacity of the data.</p><p>The second line of the code above actually allocated the three fields on the heap, Pointer to the data, size of the data, and the capacity of the data. And we uses a pointer to access the object.</p><p>Values Allocated in Rust without Smart Pointer were all like the first line of the code above. Which is, All fields allocated on the stack.</p><p>Smart pointer is like the Vector above(actually vector is a smart pointer), it allocates the fields on the stack, including a pointer to the actual object.</p><h4 id=fixed-size>Fixed size?</h4><p>Actually, a class defination determined that class is also fixed size, just like the struct.</p><p>But class has a special feature: <strong>Polymorphism</strong>.</p><p>That&rsquo;s is, when you reference an class object, it may not be the exactly the type, but a derived type. And derived type may have more fields than the base type. Which means the size of the object is not fixed.</p><h4 id=struct-and-class>Struct and Class</h4><p>Struct instance were allocated on the stack by default, and class instance were allocated on the heap by default.</p><p>Since the struct is allocated on the stack, we Call it <strong>Value Type</strong>. Value means we are not accessing it by a pointer, reference or something like that. But directly, we can touch it.</p><h5 id=why-i-declared-the-vector-as-a-struct>Why I declared the <code>Vector</code> as a struct?</h5><p>Simply because C++ allows you allocate a class instance on the stack. And I don&rsquo;t want to make things confusing for people uses other languages.</p><p>although this loses the most important feature of the class: polymorphism, which makes a class like a struct.</p><h4 id=why-all-instances-allocated-on-the-stack-must-be-fixed-size>Why All instances allocated on the stack MUST be fixed size?</h4><p>Allocation calls for Value Types were generated at the the compile time, and the size of the object must be known at the compile time.</p><p>Also, the allocations calls hardcoded the size of the object, which means the size of the object must be fixed.</p><p>Since the class has a special feature: Polymorphism, the size of the object is not fixed, so we can&rsquo;t allocate it on the stack. But without Polymorphism, we can allocate a class instance on the stack, just like C++ does.</p><h5 id=micro-views-of-the-stack>Micro views of the stack</h5><p>I&rsquo;ve talked about where is the heap, but not the stack. Stack is also a contiguous memory block. For simplicity, I&rsquo;ll say that stack were managed by the OS, although it&rsquo;s not true in some cases.</p><p>Stack of a program is Program Stack or Call Stack or Execution Stack. It&rsquo;s used to store the local variables, function parameters, and the return address of the function.</p><p>When a process starts, the OS will allocate a memory block for the process. And make a certain register point to the end of the memory block(High address). This register is called the <strong>Stack Pointer</strong>, which is <code>rsp</code> in x86_64 and <code>sp</code> in RISC-V.</p><p>When you try allocate an instance on the stack, like, a int, we simply minus the stack pointer.</p><p>You might know stack is FILO or LIFO, but that doesn&rsquo;t mean we have to pop the stack if we want to access the inner object. The FILO or LIFO is only for the stack frame, which keeps everything essential to allow function calling/returning.</p><p>Since all instance on the stack is fixed size, all of their position is fixed, we know where the object is at the compile time. We know that all local variables can be accessed by frame pointer plus a fixed offset.</p><p>Actually, we have to uses <strong>address</strong> to access all memory blocks, including those allocated on the stack. But we seems never uses a pointer. That&rsquo;s because when we have to uses a pointer, the address can NOT be known at the compile time, we have to fetch the address at runtime. But for those allocated on the stack, the known local variables, we know where they are, we can access them directly with <code>sp + offset</code>, where offset is a constant. So the address(<code>sp + offset</code>) is <strong>embedded</strong> in the instruction.</p><p>The stack is array-like, but not a real array. It&rsquo;s a memory block, a memory block means that you can access whatever you want with the memory block. Stack is just a convention which constraints the way we access the memory block - FILO or LIFO.</p><p>An example is that, in Rust, we don&rsquo;t have a specific data structure for Stack. In C++, in python, in .NET you would have a Type like <code>Stack&lt;T></code>, but in Rust, we don&rsquo;t have that. We just use <code>Vec&lt;T></code>(<code>vector&lt;T></code> in Cpp). As long as you only call push and pop method.</p><h6 id=why-the-stack-is-faster-than-the-heap>Why the stack is faster than the heap?</h6><p>When we access the object on the stack, we know where the object is, we access it with a single instruction which contains the frame pointer and the offset.</p><p>But when we access the object on the heap, we have to read the pointer to a register, and then access the object with the pointer. That&rsquo;s two instructions.</p><p>Also, accessing instance on the heap may cause cache miss, which is the REAL reason that heap is slower than the stack.</p><h5 id=micro-views-of-the-stack-allocation>Micro views of the stack allocation</h5><p>Having talked about the stack so much, you might wonder when do we push and pop.</p><p>The name of call stack implied that the stack has strong connection with <em>Fuction Call</em>.</p><p>You must have seen stack trace when the runtime throw an exception. The stack trace is actually the call stack.</p><p>Stack trace when a exception is thrown in .NET:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Unhandled exception. System.Exception: Exception from Buz
</span></span><span class=line><span class=cl>   at Program.Buz() in /home/caiyi/loongson-blog/content/post/move-semantic/StackTraceDemo/Program.cs:line 24
</span></span><span class=line><span class=cl>   at Program.Bar() in /home/caiyi/loongson-blog/content/post/move-semantic/StackTraceDemo/Program.cs:line 17
</span></span><span class=line><span class=cl>   at Program.Foo() in /home/caiyi/loongson-blog/content/post/move-semantic/StackTraceDemo/Program.cs:line 11
</span></span><span class=line><span class=cl>   at Program.Main(String[] args) in /home/caiyi/loongson-blog/content/post/move-semantic/StackTraceDemo/Program.cs:line 5
</span></span></code></pre></td></tr></table></div></div><p>Remove some of the information, we get:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>   at Program.Buz() in Program.cs:line 24
</span></span><span class=line><span class=cl>   at Program.Bar() in Program.cs:line 17
</span></span><span class=line><span class=cl>   at Program.Foo() in Program.cs:line 11
</span></span><span class=line><span class=cl>   at Program.Main(String[] args) in Program.cs:line 5
</span></span></code></pre></td></tr></table></div></div><p>Code can be obtained from <a class=link href=https://github.com/Loongson-neuq/blog/tree/main/content/post/move-semantic/StackTraceDemo target=_blank rel=noopener>https://github.com/Loongson-neuq/blog/tree/main/content/post/move-semantic/StackTraceDemo</a></p><p>Why do we have so many functions from the Stack trace? Because the functions are called nestedly.</p><p>The top function is where the exception was actually thrown, and the lower function is where the top function was called. Since the main thread of our program begins with <code>Main()</code> function, the bottom function is always <code>Main()</code>.</p><p>When a function is called, the runtime will push a new frame to the stack, and when the function returns, the runtime will pop the frame from the stack.</p><p><strong>A frame stores everyting essential to restore the envrionment before the function was the frame call another function.</strong></p><p>We know that CPU must read datas to its own <em>register</em> to do the calculation, and the register is limited. So we have to store the local variables and other things in somewhere else. That&rsquo;s the stack frame. A frame only stores datas of the function, and the frame is popped when the function returns.</p><h6 id=lets-look-at-some-assembly-code>Let&rsquo;s look at some assembly code</h6><p>Having talked about how the stack so much, you might think it&rsquo;s rather complicated to push and pop the stack. But it&rsquo;s not. As I said before, we only have to minus the stack pointer and the minused size of memory is yours! To return the memory, we only have to add the size to the stack pointer.</p><p><strong>NO NEED TO CLEAR THE MEMORY when we push/pop the stack. CAN YOU THINK ABOUT WHY?</strong></p><p>The same code as the one at the beginning of the article:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Cpp data-lang=Cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Object</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>StructType</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Object</span><span class=o>*</span> <span class=n>obj</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>str</span> <span class=o>=</span> <span class=s>&#34;Hello, world&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>StructType</span> <span class=n>value</span> <span class=o>=</span> <span class=n>StructType</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The assembly code of the function <code>foo</code> is like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>section .data
</span></span><span class=line><span class=cl>str db &#34;Hello, world&#34;, 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>section .text
</span></span><span class=line><span class=cl>global foo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>foo:
</span></span><span class=line><span class=cl>    ; 函数开始，保存栈帧
</span></span><span class=line><span class=cl>    push rbp                     ; 保存原始栈帧
</span></span><span class=line><span class=cl>    mov rbp, rsp                 ; 设置新的栈帧
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ; int i = 0;
</span></span><span class=line><span class=cl>    mov dword ptr [rbp-4], 0     ; 将变量 i 初始化为 0，并保存在栈中偏移 -4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ; int* p = &amp;i;
</span></span><span class=line><span class=cl>    lea rax, [rbp-4]             ; 取得变量 i 的地址
</span></span><span class=line><span class=cl>    mov qword ptr [rbp-8], rax   ; 将 p 指向 i 的地址并保存偏移 -8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ; Object* obj = new Object();
</span></span><span class=line><span class=cl>    mov edi, 4                   ; Object 的大小为 4 字节
</span></span><span class=line><span class=cl>    call _Znwm                   ; 调用 operator new
</span></span><span class=line><span class=cl>    mov qword ptr [rbp-16], rax  ; 保存返回的对象地址到 obj 中（偏移 -16）
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ; std::string str = &#34;Hello, world&#34;;
</span></span><span class=line><span class=cl>    lea rdi, [rel str]           ; 将字符串地址加载到 rdi
</span></span><span class=line><span class=cl>    lea rsi, [rbp-32]            ; 准备 str 变量的栈位置（偏移 -32）
</span></span><span class=line><span class=cl>    call _ZNSsC1EPKc             ; 调用 std::string 构造函数
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ; StructType value = StructType {1, 2, 3};
</span></span><span class=line><span class=cl>    mov dword ptr [rbp-48], 1    ; 将 1 存储到 value.value1（偏移 -48）
</span></span><span class=line><span class=cl>    mov dword ptr [rbp-44], 2    ; 将 2 存储到 value.value2（偏移 -44）
</span></span><span class=line><span class=cl>    mov dword ptr [rbp-40], 3    ; 将 3 存储到 value.value3（偏移 -40）
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ; 函数结束，恢复栈帧并返回
</span></span><span class=line><span class=cl>    mov rsp, rbp                 ; 恢复原始栈指针
</span></span><span class=line><span class=cl>    pop rbp                      ; 弹出原始栈帧
</span></span><span class=line><span class=cl>    ret                          ; 返回
</span></span></code></pre></td></tr></table></div></div><p>We even do have to actually DO a allocation operation. We just know that where every variable should be and read/wirte the place directly. See instructions like <code>mov dword ptr [rbp...], ...</code></p><p>Additinally, <code>push</code> and <code>pop</code> instructions are also used to store/access the stack, but they are just pseduo instructions. The real instructions are <code>mov</code> and <code>add</code>.</p><p>From the assembly code, we can see that how much we push/pop the stack is determined at the compile time, hard coded in the assembly instructions. You should know why all value types must be fixed size now.</p><p>Since we only care about current frame, which is at the top of the stack, we don&rsquo;t need to have store the size of every frame, the base of the whole stack, or the end of the stack. We only need to store the stack pointer, which is the top of the stack, or the base of the current frame.</p><p>Then I&rsquo;ll talk about why do we never clean the stack.</p><p>When we pop a frame, the depth of stack just got smaller, and there will be no chance of reading uninitialized data or overwriting the data.</p><p>When we push a frame, we always write the data before we can access it. Remember that the Compiler always say <code>Uninitialized variable</code> when you try to access a variable before you write it. The compiler gurantee that you will never read uninitialized data at the compile time, so we don&rsquo;t have to clear the memory, which makes function call faster.</p><h3 id=data-inconsistency-issue-in-multi-threaded-scenarios>Data inconsistency issue in Multi-threaded scenarios</h3><p>Watch a demo</p><p>or Download and run yourself</p><p><a class=link href=https://github.com/Loongson-neuq/blog/tree/main/content/post/move-semantic/MuitlThreadDemo target=_blank rel=noopener>https://github.com/Loongson-neuq/blog/tree/main/content/post/move-semantic/MuitlThreadDemo</a></p><p>Note: You need to have a .NET 8 runtime installed to run the demo. Install it from
<a class=link href=https://dot.net/download target=_blank rel=noopener>dot.net</a></p><h4 id=lock>Lock</h4><h4 id=read-write-lock>Read-write Lock</h4><p>We don&rsquo;t really have to lock the whole object always. In fact, the lock is to resolve the data inconsistency issue, and the data inconsistency issue is caused by the write operation.</p><p>If all threads is just <em>reading</em> the data, the data never changes, it&rsquo;s just there. So we can allow multiple threads to read the data at the same time as long as there&rsquo;s no thread is writing the data.</p><p>So the key is:</p><ul><li>Only allow one thread to write the data</li><li>Allow multiple threads to read the data</li><li>Can&rsquo;t have read lock and write lock at the same time</li></ul><p>The lock that can resolve the issue is called <strong>Read-Write Lock</strong>.</p><p>Think about Rust&rsquo;s borrow rule? Did you find the similarity?</p><h2 id=rust>Rust</h2><p><strong>WARN: the follow content were generated by ChatGPT</strong></p><h3 id=understanding-rusts-ownership-and-borrowing-rules-through-the-lens-of-read-write-locks-and-stack-memory-management>Understanding Rust&rsquo;s Ownership and Borrowing Rules through the Lens of Read-Write Locks and Stack Memory Management</h3><p>Rust’s <strong>Single Owner Rule</strong> and <strong>Single Mutable Reference Rule</strong> can be better understood when examined through the principles behind <strong>read-write locks</strong> and <strong>stack-based memory management</strong>.</p><h4 id=rusts-ownership-and-borrowing-rules-as-a-read-write-lock-analogy>Rust’s Ownership and Borrowing Rules as a Read-Write Lock Analogy</h4><p>In multi-threaded environments, a <strong>read-write lock</strong> is a synchronization mechanism allowing multiple readers to access a resource simultaneously or granting exclusive access to a single writer. Rust’s ownership and borrowing rules mirror this access control strategy, enforcing exclusive or shared access to data at compile time:</p><ol><li><p><strong>Single Owner Rule</strong>: Rust’s concept of a single owner aligns with the idea of an <strong>exclusive lock</strong> on a resource. Only one variable or function can own a piece of data at any point, ensuring exclusive access and avoiding any conflicts in memory access.</p></li><li><p><strong>Single Mutable Reference Rule</strong>: This rule is conceptually similar to read-write locks and provides two access states:</p><ul><li><strong>Shared, Immutable Access</strong>: Multiple immutable references (using <code>&amp;T</code>) to a resource are allowed, resembling the behavior of a read lock.</li><li><strong>Exclusive, Mutable Access</strong>: Only one mutable reference (using <code>&amp;mut T</code>) can exist at any time, akin to a write lock, preventing simultaneous modifications by others and ensuring safe mutation.</li></ul></li></ol><p>By enforcing these rules, Rust’s compiler performs a static analysis to eliminate race conditions and memory conflicts at compile time, achieving thread safety without the runtime overhead of locks.</p><h4 id=safe-memory-management-with-stack-allocation>Safe Memory Management with Stack Allocation</h4><p>Rust’s ownership rules apply to both <strong>stack</strong> and <strong>heap memory</strong> management, maintaining safety and efficiency across both types of allocations:</p><ol><li><p><strong>Stack Memory Management</strong>: In Rust, variables allocated on the stack are assigned a clear, finite lifecycle determined at compile time, corresponding to the stack’s Last-In-First-Out (LIFO) principle. The ownership system prevents issues like double frees, as the ownership rules guarantee that only the active owner has control over memory deallocation.</p></li><li><p><strong>Heap Memory Management</strong>: When data is allocated on the heap, Rust’s ownership rules still apply, managing the memory lifecycle through single ownership. Heap memory is controlled by the owning variable, and once the variable goes out of scope, the data is automatically deallocated, freeing developers from the need for manual memory management.</p></li></ol><p>Borrowing rules further ensure that data on the heap avoids race conditions. By allowing multiple immutable references (akin to a read lock) but only one mutable reference (like a write lock), Rust’s system dynamically enforces safety similar to a runtime read-write lock.</p><h4 id=case-study-ownership-and-borrowing-in-action-with-concurrency>Case Study: Ownership and Borrowing in Action with Concurrency</h4><p>To illustrate Rust’s ownership and borrowing in action, let’s consider a simple multithreaded example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>thread</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Transfer ownership of `data` to the spawned thread.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>data</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span><span class=w> </span><span class=c1>// Mutating `data`, ownership is now exclusively with the new thread.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>handle</span><span class=p>.</span><span class=n>join</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Any attempt to access `data` in the main thread would result in a compilation error,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// as ownership has been transferred.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>In this example, ownership of <code>data</code> is transferred to the new thread using <code>move</code>, meaning the main thread no longer has access to it. This model functions similarly to an exclusive lock but relies on ownership transfer rather than explicit locks. Rust’s ownership system enforces access control here without locks, allowing memory allocation to remain efficient while eliminating data races at compile time.</p><h4 id=rusts-advantage-compile-time-lock-like-guarantees>Rust’s Advantage: Compile-Time Lock-Like Guarantees</h4><p>Compared to traditional lock-based synchronization, Rust’s ownership and borrowing rules rely on compile-time checks to ensure memory safety, removing the need for runtime locks. The Rust compiler statically analyzes a variable’s lifecycle and reference status, ensuring memory access safety without runtime overhead, which both boosts memory efficiency and minimizes errors.</p><h3 id=conclusion>Conclusion</h3><p>Rust’s ownership and borrowing model integrates the benefits of read-write locks with stack-based memory management principles. By statically enforcing exclusive or shared access, Rust guarantees thread safety and efficient memory management without the performance costs of locks. This unique approach ensures that concurrent programming in Rust is both efficient and safe by design.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/rust/>Rust</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/os-week2-get-started-with-rust/><div class=article-details><h2 class=article-title>[OS Week2] Get started with Rust</h2></div></a></article><article class=has-image><a href=/p/os-week1-git-and-linux-basics/><div class=article-image><img src=/p/os-week1-git-and-linux-basics/background.bf6810ec384f763b831c15f3672eb91e_hub7bd9424949445f7cb4edac68fee9448_2942088_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy alt="Featured image of post [OS Week1] Git and Linux Basics" data-hash="md5-v2gQ7DhPdjuDHBXzZy65Hg=="></div><div class=article-details><h2 class=article-title>[OS Week1] Git and Linux Basics</h2></div></a></article><article><a href=/p/os-week6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-2-rust-%E6%89%80%E6%9C%89%E6%9D%83/><div class=article-details><h2 class=article-title>[OS Week6] 内存管理 2 & Rust 所有权</h2></div></a></article><article><a href=/p/os-week2-%E4%BD%9C%E4%B8%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/><div class=article-details><h2 class=article-title>[OS Week2] 作业常见问题</h2></div></a></article><article><a href=/p/os-week1-%E4%BD%9C%E4%B8%9A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/><div class=article-details><h2 class=article-title>[OS Week1] 作业常见问题</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=Loongson-neuq/blog data-repo-id=R_kgDOM20epQ data-category=Giscus data-category-id=DIC_kwDOM20epc4CixXm data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"preferred_color_scheme":"preferred_color_scheme")}})()</script><footer class=site-footer><section class=copyright>&copy;
2024 NEUQ 龙芯实验室博客</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>